<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
    <title>BL4 Decoder & Generic Selector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles adapted from Enhancement_Editor.html & index (12).html */
        :root {
            --bg:#0b0f14;
            --card:#0e1520;
            --ink:#e6f0ff;
            --muted:#a6b4c8;
            --line:#1f2a3a;
            --accent-orange: #e59400;
            --danger-red: #e74c3c;
            --success-green: #28a745;
            --info-blue: #0ea5e9; /* Added */
            --edit-yellow: #ffc107;
            --dup-singular: #3b82f6; /* Blue for {ID} */
            --dup-specific: #f97316; /* Orange for {X:Y} */
            --dup-array: #eab308;    /* Yellow for array values */
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; padding: 0; }
        body { font-family: 'Inter', system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--bg); color: var(--ink); font-size: 16px; line-height: 1.5; }

        .container { max-width: 1200px; margin: 0 auto; padding: 18px; } /* Main content container */

        /* --- TAB NAVIGATION STYLES --- */
        .tab-nav { background-color: var(--card); border-bottom: 1px solid var(--line); padding: 0 18px; margin-bottom: 18px; display: flex; gap: 10px; }
        .tab-link { display: inline-block; padding: 12px 16px; border: none; background: none; color: var(--muted); cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s ease; }
        .tab-link:hover { color: var(--ink); }
        .tab-link.active { color: var(--ink); border-bottom-color: var(--accent-orange); font-weight: 500; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* --- CARD STYLES --- */
        .card { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 14px 16px; margin-bottom: 18px; }
        .card h2 { margin: 0 0 14px; font-size: 1.1rem; font-weight: 500; display: flex; justify-content: space-between; align-items: center; }

        /* --- COLLAPSIBLE STYLES --- */
        .collapsible-content { display: none; margin-top: 10px; }
        .collapsible-content.expanded { display: block; }
        .toggle-btn { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 1.2rem; padding: 0 5px; line-height: 1; transition: transform 0.2s ease; margin-left: auto; /* Push to right */ }
        .toggle-btn::before { content: '▶'; display: inline-block; }
        .toggle-btn.expanded::before { content: '▼'; }

        /* --- FORM ELEMENTS & BUTTONS --- */
        label { color: var(--muted); font-size: 12px; display: block; margin-bottom: 6px; }
        select, input[type="text"], input[type="number"], textarea, button { background: #0f1720; color: var(--ink); border: 1px solid var(--line); border-radius: 10px; padding: 10px 12px; font-size: inherit; transition: background-color 0.2s, border-color 0.2s; }
        select, input[type="text"], input[type="number"], textarea { width: 100%; }
        select[multiple] { padding: 5px; } /* Reduce padding for multi-selects */
        textarea { resize: vertical; min-height: 60px; font-family: monospace; }
        button { cursor: pointer; background-color: #1f2a3a; }
        button:hover { background-color: #2c3a4f; }
        button:disabled { cursor: not-allowed; opacity: 0.5; }
        button.primary { background-color: var(--accent-orange); color: #0b0f14; font-weight: 500; }
        button.primary:hover { background-color: #ffae1a; }
        button.danger { background-color: var(--danger-red); }
        button.danger:hover { background-color: #f76c5c; }
        button.small { padding: 6px 10px; border-radius: 8px; font-size: 0.9em; }

        /* --- UTILITY & LAYOUT --- */
        .row { display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 12px; align-items: center; }
        .flex-1 { flex: 1; min-width: 120px; /* Prevent shrinking too much */ }
        .space-y-4 > * + * { margin-top: 1rem; }
        .mt-4 { margin-top: 1rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .font-mono { font-family: monospace; }
        .text-sm { font-size: 0.875rem; }
        .text-xs { font-size: 0.75rem; }
        .text-muted { color: var(--muted); }
        .block { display: block; }
        .w-full { width: 100%; }

        /* --- CODE & OUTPUT --- */
        code { background: #0c121b; border: 1px solid var(--line); padding: 10px; display: block; border-radius: 8px; font-family: 'Courier New', Courier, monospace; font-size: 0.95em; white-space: pre-wrap; word-break: break-all; }
        #out code { outline: none; } /* Remove focus outline for contenteditable */
        #out { position: relative; } /* Needed for indicator positioning */
        .manual-edit-indicator { display: none; position: absolute; top: 5px; right: 5px; background-color: var(--edit-yellow); color: #0b0f14; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: bold; }
        #out.manual-edit .manual-edit-indicator { display: inline; }
        #out code.manual-edit { border-color: var(--edit-yellow); box-shadow: 0 0 5px var(--edit-yellow); }
        .added-part { background-color: #2c3a4f; padding: 0 2px; border-radius: 3px; }

        /* --- DUPLICATE HIGHLIGHTING --- */
        .dup-singular { color: var(--dup-singular); font-weight: bold; } /* Blue for {ID} */
        .dup-specific { color: var(--dup-specific); font-weight: bold; } /* Orange for {X:Y} */
        .dup-array-value { color: var(--dup-array); font-weight: bold; } /* Yellow for array values */

        /* --- BUILDER SECTION --- */
        .builderSection .titleRow { display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .builderSection .filterRow { gap: 5px; flex-wrap: nowrap; }
        .builderSection .filterRow input { flex-grow: 1; }
        .builderSection .selects { display: flex; gap: 10px; align-items: stretch; }
        .builderSection select { flex: 1; min-height: 150px; }
        .builderSection .buttons { display: flex; flex-direction: column; justify-content: center; gap: 10px; }
        .builderSection .buttons button { padding: 8px 10px; }
        .builderSection .tip { font-size: 0.8rem; color: var(--muted); margin-top: 5px; text-align: center; }

        /* --- API SECTION --- */
        .apiResult { background: #0c121b; border: 1px solid var(--line); padding: 10px; border-radius: 8px; margin-top: 5px; min-height: 40px; font-family: monospace; font-size: 0.9em; white-space: pre-wrap; word-break: break-all; }
        .copy-status { display: inline-block; margin-left: 8px; color: var(--success-green); font-size: 0.8em; opacity: 0; transition: opacity 0.3s; }
        .copy-status.visible { opacity: 1; }

        /* --- MESSAGE TOAST --- */
        .message-toast { visibility: hidden; min-width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 8px; padding: 12px 16px; position: fixed; z-index: 100; left: 50%; transform: translateX(-50%); bottom: 30px; font-size: 1rem; opacity: 0; transition: visibility 0s 0.3s, opacity 0.3s ease-out; display: flex; align-items: center; gap: 10px; }
        .message-toast.show { visibility: visible; opacity: 1; transition: visibility 0s, opacity 0.3s ease-in; }
        .message-toast.success { background-color: var(--success-green); color: white; }
        .message-toast.error { background-color: var(--danger-red); color: white; }
        .message-toast.info { background-color: var(--info-blue); color: white; }
        .message-toast code { background: rgba(0,0,0,0.2); padding: 2px 4px; border-radius: 4px; font-size: 0.9em; border: none; }
        .toast-icon { font-size: 1.2rem; }

        /* --- DUPLICATE INFO AREA --- */
        #duplicateInfoContainer { margin-top: 10px; }
        #duplicateInfoOutput { font-size: 0.85rem; color: var(--muted); margin-top: 8px; white-space: pre-wrap; background: #0c121b; border: 1px solid var(--line); padding: 8px; border-radius: 6px; }

    </style>
</head>
<body>

    <!-- --- TAB NAVIGATION BAR --- -->
    <nav class="tab-nav">
        <button class="tab-link active" data-tab="tab-decoder">Decoder/Editor</button>
        <button class="tab-link" data-tab="tab-selector">Generic Selector</button>
        <button class="tab-link" data-tab="tab-api">API Info</button>
    </nav>

<div class="container">

    <!-- --- TAB CONTENT: Decoder/Editor --- -->
    <div id="tab-decoder" class="tab-content active">

        <div class="card space-y-4">
            <h2 class="text-xl font-semibold">Input Serial Code</h2>
            <div>
                <label for="baseSerial">Paste Deserialized String OR B85 Serial (@U...)</label>
                <textarea id="baseSerial" class="font-mono text-sm" placeholder="Paste deserialized code (e.g., 7, 0, 1, 50| 2, 1234|| {1} {2}) OR a B85 serial (@U...)"></textarea>
            </div>
            <div class="row">
                <button id="deserializeBtn" class="primary">Deserialize Serial Code</button>
                <button id="applyInputBtn">Apply Code Block to Editor</button>
                 <span class="text-xs text-muted">(Click Deserialize first if pasting @U code, then Apply)</span>
            </div>
        </div>

        <div class="card space-y-4">
            <h2 class="text-xl font-semibold">Generated Output & Controls</h2>
            <div id="out">
                <label for="outCode" class="block mb-2">Edit Serial Code (Editable - Manual edits disable auto-update)</label>
                <code id="outCode" contenteditable="true" class="font-mono text-sm">[Output will appear here]</code>
                <span class="manual-edit-indicator">Manual Edit Mode</span>
            </div>
             <div id="duplicateInfoContainer">
                <button id="analyzeDuplicatesBtn" class="small">Show Duplicate Info</button>
                <div id="duplicateInfoOutput"></div>
            </div>
            <div class="row">
                <button id="copyFull">Copy Output <span id="copyFullStatus" class="copy-status"></span></button>
                <button id="undoEdit" class="danger small" title="Revert manual edits and use builder output">Undo Manual Edit</button>
                 <button id="reserializeManual" class="small" title="Manually trigger API call with current output text">Force API Call</button>
            </div>
        </div>

        <div id="mainContent">
            <!-- Base Item Card -->
            <div class="card collapsible" id="baseItemCard">
                 <h2>Base Item Properties</h2>
                 <div class="collapsible-content">
                     <div class="row">
                        <div style="flex: 1;">
                            <label>Base Item Type (Placeholder)</label>
                            <select id="itemTypeSel">
                                <option value="gun">Generic Gun</option>
                                <option value="shield">Shield</option>
                                <option value="grenade">Grenade Mod</option>
                                <option value="classmod">Class Mod</option>
                                <option value="enhancement">Enhancement</option>
                            </select>
                        </div>
                         <div style="flex: 1;">
                            <label>Rarity (Placeholder)</label>
                            <select id="raritySel">
                                <option value="common">Common</option>
                                <option value="uncommon">Uncommon</option>
                                <option value="rare">Rare</option>
                                <option value="epic">Epic</option>
                                <option value="legendary">Legendary</option>
                            </select>
                        </div>
                     </div>
                 </div>
            </div>
            <!-- Legendary Perks -->
            <div class="card builderSection collapsible" data-key="legendaryPerks" data-name-field="name" data-code-field="code" data-id-prefix="LegPerk">
                 <div class="row titleRow">
                     <div>Legendary Perk Part Variations</div>
                     <div class="row filterRow">
                        <input id="filterLegPerk" placeholder="Filter..." type="text"/>
                        <button class="small" id="clearLegPerk" title="Clear Selected">❌</button>
                    </div>
                </div>
                 <div class="collapsible-content">
                    <div class="row selects">
                        <select id="availLegPerk" multiple size="8" aria-label="Available Legendary Perks"></select>
                        <div class="buttons">
                            <button id="addLegPerk" title="Add Selected">»</button>
                            <button id="remLegPerk" title="Remove Selected">«</button>
                        </div>
                        <select id="selLegPerk" multiple size="8" aria-label="Selected Legendary Perks"></select>
                    </div>
                     <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
                 </div>
            </div>
            <!-- Alt Fire Modes -->
            <div class="card builderSection collapsible" data-key="altFireModes" data-name-field="name" data-code-field="code" data-id-prefix="AltFire">
                <div class="row titleRow">
                    <div>Alt Fire Mode Variations</div>
                    <div class="row filterRow">
                        <input id="filterAltFire" placeholder="Filter..." type="text"/>
                        <button class="small" id="clearAltFire" title="Clear Selected">❌</button>
                    </div>
                </div>
                 <div class="collapsible-content">
                    <div class="row selects">
                        <select id="availAltFire" multiple size="8" aria-label="Available Alt Fire Modes"></select>
                        <div class="buttons">
                            <button id="addAltFire" title="Add Selected">»</button>
                            <button id="remAltFire" title="Remove Selected">«</button>
                        </div>
                        <select id="selAltFire" multiple size="8" aria-label="Selected Alt Fire Modes"></select>
                    </div>
                     <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
                </div>
            </div>
            <!-- Magazine Modes -->
            <div class="card builderSection collapsible" data-key="magazineModes" data-name-field="name" data-code-field="code" data-id-prefix="MagMode">
                 <div class="row titleRow">
                    <div>Magazine / Ammo Mode Variations</div>
                     <div class="row filterRow">
                        <input id="filterMagMode" placeholder="Filter..." type="text"/>
                        <button class="small" id="clearMagMode" title="Clear Selected">❌</button>
                    </div>
                </div>
                 <div class="collapsible-content">
                    <div class="row selects">
                        <select id="availMagMode" multiple size="8" aria-label="Available Magazine/Ammo Modes"></select>
                        <div class="buttons">
                            <button id="addMagMode" title="Add Selected">»</button>
                            <button id="remMagMode" title="Remove Selected">«</button>
                        </div>
                        <select id="selMagMode" multiple size="8" aria-label="Selected Magazine/Ammo Modes"></select>
                    </div>
                     <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
                </div>
            </div>

            <!-- ----- Elements Section ----- -->
            <div class="card builderSection collapsible" data-key="weaponElements" data-name-field="name" data-code-field="code" data-id-prefix="Elem">
                 <div class="row titleRow">
                     <div>Elements</div>
                     <div class="row filterRow">
                        <input id="filterElem" placeholder="Filter..." type="text"/>
                        <button class="small" id="clearElem" title="Clear Selected">❌</button>
                    </div>
                </div>
                 <div class="collapsible-content">
                    <div class="row selects">
                        <select id="availElem" multiple size="8" aria-label="Available Elements"></select>
                        <div class="buttons">
                            <button id="addElem" title="Add Selected">»</button>
                            <button id="remElem" title="Remove Selected">«</button>
                        </div>
                        <select id="selElem" multiple size="8" aria-label="Selected Elements"></select>
                    </div>
                     <div class="tip">Double-click to add/remove. Handles primary {1:X} and secondary {1:Y} element codes.</div>
                 </div>
            </div>
            <!-- ----- END Elements Section ----- -->

            <!-- Ordnance Perks -->
            <div class="card builderSection collapsible" data-key="ordnancePerks" data-name-field="name" data-code-field="code" data-id-prefix="OrdPerk">
                 <div class="row titleRow">
                    <div>Ordnance Legendary Perks (Heavy/Grenade)</div>
                     <div class="row filterRow">
                        <input id="filterOrdPerk" placeholder="Filter..." type="text"/>
                        <button class="small" id="clearOrdPerk" title="Clear Selected">❌</button>
                    </div>
                </div>
                 <div class="collapsible-content">
                    <div class="row selects">
                        <select id="availOrdPerk" multiple size="8" aria-label="Available Ordnance Perks"></select>
                        <div class="buttons">
                            <button id="addOrdPerk" title="Add Selected">»</button>
                            <button id="remOrdPerk" title="Remove Selected">«</button>
                        </div>
                        <select id="selOrdPerk" multiple size="8" aria-label="Selected Ordnance Perks"></select>
                    </div>
                     <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
                 </div>
            </div>

            <!-- ----- Skins/Camo Section ----- -->
            <div class="card builderSection collapsible" data-key="weaponSkins" data-name-field="name" data-code-field="code" data-id-prefix="Skin">
                 <div class="row titleRow">
                     <div>Skins / Camo</div>
                     <div class="row filterRow">
                        <input id="filterSkin" placeholder="Filter..." type="text"/>
                        <button class="small" id="clearSkin" title="Clear Selected">❌</button>
                    </div>
                </div>
                 <div class="collapsible-content">
                    <div class="row selects">
                        <select id="availSkin" multiple size="8" aria-label="Available Weapon Skins"></select>
                        <div class="buttons">
                            <button id="addSkin" title="Add Selected">»</button>
                            <button id="remSkin" title="Remove Selected">«</button>
                        </div>
                        <select id="selSkin" multiple size="8" aria-label="Selected Weapon Skins"></select>
                    </div>
                     <div class="tip">Double-click to add/remove. Note: Skins often use specific block formats like `"c", XX|`. This builder adds the raw code block. May require manual adjustment.</div>
                 </div>
            </div>
            <!-- ----- END Skins/Camo Section ----- -->

        </div> <!-- End mainContent -->

    </div> <!-- End tab-decoder -->

    <!-- --- TAB CONTENT: Generic Selector --- -->
    <div id="tab-selector" class="tab-content">
        <div class="card space-y-4">
            <h2 class="text-xl font-semibold">Generic Part Selector</h2>
            <div>
                <label for="selectorDataset">Select Dataset:</label>
                <select id="selectorDataset">
                    <option value="legendaryPerks">Legendary Perks (Example)</option>
                    <option value="enhancementStats">Enhancement Stats (Example)</option>
                    <!-- Add more options here as PAYLOAD is populated -->
                </select>
            </div>
            <div class="row selects">
                 <div style="flex: 1;">
                     <label for="selectorAvailable">Available:</label>
                    <input id="selectorFilter" placeholder="Filter available..." type="text" class="mb-2 w-full"/>
                    <select id="selectorAvailable" multiple size="10" aria-label="Available Generic Items"></select>
                 </div>
                 <div class="buttons">
                    <button id="selectorAddBtn" title="Add Selected">»</button>
                    <button id="selectorRemoveBtn" title="Remove Selected">«</button>
                </div>
                <div style="flex: 1;">
                    <label for="selectorSelected">Selected:</label>
                    <select id="selectorSelected" multiple size="10" aria-label="Selected Generic Items"></select>
                </div>
            </div>
            <div>
                 <label for="selectorOutput">Generated Output:</label>
                 <code id="selectorOutput" class="font-mono text-sm">[Selected items output]</code>
             </div>
        </div>
    </div> <!-- End tab-selector -->

    <!-- --- TAB CONTENT: API Info --- -->
    <div id="tab-api" class="tab-content">
        <div class="card space-y-4">
            <h2 class="text-xl font-semibold">API Interaction</h2>
             <div>
                <label>New Serial (from API):</label>
                <div id="serial_b85" class="apiResult">[API Serial will appear here]</div>
                <button id="copySerial" disabled>Copy API Serial <span id="copyApiStatus" class="copy-status"></span></button>
             </div>
             <div>
                 <label>Details (from API):</label>
                <div id="additionalData" class="apiResult">[Additional data from API will appear here]</div>
             </div>
             <p class="text-xs text-muted">API Endpoint: https://borderlands4-deserializer.nicnl.com/api/v1/reserialize</p>
        </div>
    </div> <!-- End tab-api -->

</div> <!-- End container -->

<!-- Message Toast -->
<div id="messageToast" class="message-toast">
    <span id="toastIcon" class="toast-icon">✓</span>
    <span id="toastText">Success!</span>
</div>

<script>
    // Global variables
    let PAYLOAD = {}; // Initialize as empty object
    const builders = {};
    let apiCallTimer;
    let rebuildTimer;
    let lastGeneratedOutput = '';
    let isManualEditMode = false;
    let messageTimeout;
    let currentBaseInputString = ''; // Store the applied base input

    // --- DOM Elements Cache ---
    const dom = {
        body: document.body,
        messageArea: document.getElementById('message-area'), // Legacy, use Toast
        itemTypeSel: document.getElementById('itemTypeSel'),
        raritySel: document.getElementById('raritySel'),
        outWrapper: document.getElementById('out'),
        outCode: document.querySelector('#out code'),
        baseSerial: document.getElementById('baseSerial'),
        serial_b85: document.getElementById('serial_b85'),
        additionalData: document.getElementById('additionalData'),
        copyFull: document.getElementById('copyFull'),
        copySerial: document.getElementById('copySerial'),
        // dice removed
        copyFullStatus: document.getElementById('copyFullStatus'),
        copyApiStatus: document.getElementById('copyApiStatus'),
        undoEditBtn: document.getElementById('undoEdit'),
        reserializeManualBtn: document.getElementById('reserializeManual'),
        applyInputBtn: document.getElementById('applyInputBtn'),
        deserializeBtn: document.getElementById('deserializeBtn'),
        messageToast: document.getElementById('messageToast'),
        toastIcon: document.getElementById('toastIcon'),
        toastText: document.getElementById('toastText'),
        analyzeDuplicatesBtn: document.getElementById('analyzeDuplicatesBtn'),
        duplicateInfoOutput: document.getElementById('duplicateInfoOutput')
    };

    // --- Utility Functions ---
    function showMessage(text, type = 'info', duration = 3000) {
        if (!dom.messageToast || !dom.toastIcon || !dom.toastText) {
            console.warn("Toast elements not found, logging message instead:", type, text);
            return;
        }
        clearTimeout(messageTimeout);
        dom.toastIcon.textContent = type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️';
        dom.toastText.innerHTML = text; // Use innerHTML to render code tags if present
        dom.messageToast.className = `message-toast ${type} show`;
        messageTimeout = setTimeout(() => {
            dom.messageToast.classList.remove('show');
        }, duration);
    }
    function showCopyStatus(statusElement, message) {
        if (!statusElement) return;
        statusElement.textContent = message;
        statusElement.classList.add('visible');
        clearTimeout(statusElement.timer);
        statusElement.timer = setTimeout(() => {
            statusElement.classList.remove('visible');
        }, 1500);
    }
    // Simple debounce function
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }


    // --- Collapsible Section Logic ---
    function setupCollapsibleSections() {
        const collapsibleCards = document.querySelectorAll('.card.collapsible');
        collapsibleCards.forEach(card => {
            const header = card.querySelector('h2') || card.querySelector('.row.titleRow');
            const content = card.querySelector('.collapsible-content');
            if (!header || !content) {
                console.warn('Collapsible structure incorrect:', card);
                return;
            }
            if (header.querySelector('.toggle-btn')) return; // Already initialized

            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'toggle-btn';
            toggleBtn.setAttribute('aria-expanded', 'false');
            toggleBtn.title = 'Toggle Section';

            if (header.tagName === 'H2') {
                header.appendChild(toggleBtn);
            } else if (header.classList.contains('titleRow')) {
                 const filterRow = header.querySelector('.filterRow');
                 if (filterRow) header.insertBefore(toggleBtn, filterRow);
                 else header.appendChild(toggleBtn);
            }

            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent card click if needed
                const isExpanded = content.classList.toggle('expanded');
                toggleBtn.classList.toggle('expanded', isExpanded);
                toggleBtn.setAttribute('aria-expanded', isExpanded);
            });

             const startExpanded = card.classList.contains('start-expanded');
             if (startExpanded) {
                 content.classList.add('expanded');
                 toggleBtn.classList.add('expanded');
                 toggleBtn.setAttribute('aria-expanded', 'true');
             }
        });
    }

    // --- Generic Builder UI Logic ---
    function createBuilder(key, nameField, codeField, idPrefix) {
        const dataList = PAYLOAD[key] || [];
        const filterInput = document.getElementById(`filter${idPrefix}`);
        const availList = document.getElementById(`avail${idPrefix}`);
        const selList = document.getElementById(`sel${idPrefix}`);
        const addBtn = document.getElementById(`add${idPrefix}`);
        const remBtn = document.getElementById(`rem${idPrefix}`);
        const clearBtn = document.getElementById(`clear${idPrefix}`);

        if (!filterInput || !availList || !selList || !addBtn || !remBtn || !clearBtn) {
            console.error(`Missing DOM elements for builder ${idPrefix}. Skipping.`);
            return { getSelectedItems: () => [], clear: () => {} }; // Return dummy object
        }

        let selectedItems = []; // Stores { code: "{X:Y}", uniqueId: number }
        let nextUniqueId = 0;
        const codeToNameMap = {};

        if (!Array.isArray(dataList)) {
            console.error(`Expected array for key ${key}, received:`, dataList);
            return { getSelectedItems: () => [], clear: () => {} }; // Return dummy object
        }

        // Pre-process data
        dataList.forEach(item => {
            const code = item[codeField];
            if (code === undefined || code === null || typeof code !== 'string') return;
            const name = item[nameField] || 'Unnamed Item';
            const variant = item.variant ? ` "${item.variant}"` : '';
            const group = item.group ? ` (${item.group})` : '';
            codeToNameMap[code.trim()] = `${name}${variant}${group}`;
        });

        function populateAvailable() {
            const fragment = document.createDocumentFragment();
            const query = (filterInput.value || '').toLowerCase();
            availList.innerHTML = '';

            (dataList || [])
                .filter(item => {
                    const code = item[codeField];
                    if (code === undefined || code === null || typeof code !== 'string') return false;
                    const name = codeToNameMap[code.trim()] || '';
                    const searchText = `${name} ${code}`.toLowerCase();
                    return !query || searchText.includes(query);
                })
                .sort((a, b) => {
                     const codeA = a[codeField]?.trim();
                     const codeB = b[codeField]?.trim();
                     const nameA = codeToNameMap[codeA] || '';
                     const nameB = codeToNameMap[codeB] || '';
                     return nameA.localeCompare(nameB);
                 })
                .forEach(item => {
                    const code = item[codeField].trim();
                    const displayName = codeToNameMap[code] || 'Unknown';
                    const o = document.createElement('option');
                    o.value = code;
                    o.textContent = `${displayName} ${code}`;
                    fragment.appendChild(o);
                });
            availList.appendChild(fragment);
        }

        function renderSelected() {
            const scrollState = { top: selList.scrollTop, left: selList.scrollLeft };
            const selectedUniqueIds = new Set(Array.from(selList.selectedOptions).map(opt => opt.value));
            selList.innerHTML = '';
            selectedItems.forEach(item => {
                const name = codeToNameMap[item.code] || 'Unknown Code';
                const o = document.createElement('option');
                o.value = item.uniqueId.toString(); // Use uniqueId as value for selection tracking
                o.textContent = `${name} ${item.code}`;
                o.dataset.code = item.code; // Store actual code in data attribute
                if (selectedUniqueIds.has(o.value)) o.selected = true;
                selList.appendChild(o);
            });
            selList.scrollTop = scrollState.top; selList.scrollLeft = scrollState.left;
             if (!isManualEditMode) triggerDebouncedRebuild();
        }

        function addSelected() {
            Array.from(availList.selectedOptions).forEach(opt => {
                selectedItems.push({ code: opt.value, uniqueId: nextUniqueId++ });
            });
            renderSelected();
        }

        function removeSelected() {
            const idsToRemove = new Set(Array.from(selList.selectedOptions).map(opt => parseInt(opt.value, 10)));
            if (idsToRemove.size === 0) return;
            selectedItems = selectedItems.filter(item => !idsToRemove.has(item.uniqueId));
            renderSelected();
        }

        function clearSelected() {
            selectedItems = [];
            renderSelected();
        }

        populateAvailable();
        filterInput.addEventListener('input', debounce(populateAvailable, 200));
        addBtn.addEventListener('click', addSelected);
        remBtn.addEventListener('click', removeSelected);
        clearBtn.addEventListener('click', clearSelected);
        selList.addEventListener('keydown', e => { if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); removeSelected(); } });
        selList.addEventListener('dblclick', removeSelected);
        availList.addEventListener('dblclick', addSelected);

        return { getSelectedItems: () => selectedItems.map(item => item.code), clear: clearSelected };
    }

    // --- Condensing Logic ---
     function getPartId(code) { const match = code.match(/\{(\d+)/); return match ? match[1] : null; }
     function condenseParts(parts) {
          if (!parts || parts.length === 0) return [];
          const grouped = {};
          const individualParts = []; // For parts not matching standard formats or added manually
          const finalCondensed = [];

          parts.forEach(code => {
              if (typeof code !== 'string' || !code.trim()) return; // Skip invalid entries
              const trimmedCode = code.trim();
              // Regex handles spaces around ':', within '[]', and optional values
              const match = trimmedCode.match(/^\s*\{(\d+)(?:\s*:\s*([^}\[\]]+)|\s*:\s*\[([^\]]+)\])?\s*\}\s*$/);
              if (match) {
                  const id = match[1];
                  const value = match[2]?.trim(); // Single value
                  const arrayValuesStr = match[3]?.trim(); // Values inside brackets
                  const valuesFromArray = arrayValuesStr ? arrayValuesStr.split(/\s+/).filter(v => v) : [];

                  if (!grouped[id]) grouped[id] = { simple: 0, values: new Set() };

                  if (value) {
                      grouped[id].values.add(value);
                  } else if (valuesFromArray.length > 0) {
                      valuesFromArray.forEach(v => grouped[id].values.add(v));
                  } else {
                      grouped[id].simple++;
                  }
              } else if (!trimmedCode.includes('||')) {
                   individualParts.push(trimmedCode);
              }
          });

          // Process grouped parts
          for (const id in grouped) {
               const group = grouped[id];
               const hasValues = group.values.size > 0;
               const hasSimple = group.simple > 0;

               if (hasValues) {
                    const sortedValues = Array.from(group.values).sort(); // Sort for consistency
                    finalCondensed.push(`{${id}:[${sortedValues.join(' ')}]}`);
               }
               // Add simple {ID} only if it existed AND (EITHER no values existed OR values also existed)
               // This prevents adding {ID} if ONLY {ID:[...]} was input, but allows {ID} {ID:V} -> {ID} {ID:[V]}
               if (hasSimple && (!hasValues || hasValues)) {
                    finalCondensed.push(`{${id}}`);
               }
          }

          return [...finalCondensed, ...individualParts]; // Combine and return
      }

    // --- Duplicate Analysis Logic ---
    function analyzeDuplicates(condensedPartsString) {
        const counts = { singular: {}, specific: {}, arrayValues: {} };
        const parts = condensedPartsString.match(/\{[^}]+\}/g) || [];

        parts.forEach(part => {
            const singularMatch = part.match(/^\{(\d+)\}$/);
            const specificMatch = part.match(/^\{(\d+):([^\[\]]+)\}$/); // Match non-array specifics
            const arrayMatch = part.match(/^\{(\d+):\[([^\]]+)\]\}$/);

            if (singularMatch) {
                const id = singularMatch[1];
                counts.singular[id] = (counts.singular[id] || 0) + 1;
            } else if (specificMatch) {
                // Treat specific parts like {X:Y} as unique entities for counting
                counts.specific[part] = (counts.specific[part] || 0) + 1;
            } else if (arrayMatch) {
                const id = arrayMatch[1];
                const values = arrayMatch[2].trim().split(/\s+/);
                const valueCounts = {};
                values.forEach(val => {
                    valueCounts[val] = (valueCounts[val] || 0) + 1;
                });
                for (const val in valueCounts) {
                    if (valueCounts[val] > 1) {
                         // Store as "ID:Value" to track duplicates within specific arrays
                         const key = `${id}:${val}`;
                         counts.arrayValues[key] = (counts.arrayValues[key] || 0) + valueCounts[val];
                    }
                }
            }
        });

        // Filter out non-duplicates
        const duplicates = { singular: {}, specific: {}, arrayValues: {} };
        for (const key in counts.singular) if (counts.singular[key] > 1) duplicates.singular[key] = counts.singular[key];
        for (const key in counts.specific) if (counts.specific[key] > 1) duplicates.specific[key] = counts.specific[key];
        // Array values already filtered for > 1 internally during counting
        duplicates.arrayValues = counts.arrayValues;


        return duplicates;
    }

    function formatDuplicateAnalysis(duplicates) {
        let output = '';
        const singularKeys = Object.keys(duplicates.singular);
        const specificKeys = Object.keys(duplicates.specific);
        const arrayValueKeys = Object.keys(duplicates.arrayValues);

        if (singularKeys.length > 0) {
            output += 'Duplicates (Singular Blocks):\n';
            singularKeys.forEach(key => { output += `  {${key}} occurs ${duplicates.singular[key]} times\n`; });
        }
        if (specificKeys.length > 0) {
            output += (output ? '\n' : '') + 'Duplicates (Specific Parts):\n';
            specificKeys.forEach(key => { output += `  ${key} occurs ${duplicates.specific[key]} times\n`; });
        }
        if (arrayValueKeys.length > 0) {
            output += (output ? '\n' : '') + 'Duplicates (Inside Array Blocks):\n';
            arrayValueKeys.forEach(key => {
                 const [id, val] = key.split(':');
                 output += `  Value ${val} occurs ${duplicates.arrayValues[key]} times in {${id}:[...]}\n`;
             });
        }

        return output || 'No significant duplicates found.';
    }

    function analyzeAndDisplayDuplicates() {
        if (!dom.outCode || !dom.duplicateInfoOutput) return;
        const currentOutput = dom.outCode.textContent || '';
        const duplicates = analyzeDuplicates(currentOutput);
        dom.duplicateInfoOutput.textContent = formatDuplicateAnalysis(duplicates);
    }


    // --- Output Rebuilding ---
    function rebuildOutput() {
        if (!dom.outCode) return;
        try {
            let currentSeed = '1234'; // Default placeholder if needed
            const seedMatch = currentBaseInputString.match(/\|\s*\d+,\s*(\d+)\s*\|\|/);
            if (seedMatch) currentSeed = seedMatch[1];
            else {
                 const simpleSeedMatch = currentBaseInputString.match(/\|\s*\d+,\s*(\d+)\s*$/);
                 if (simpleSeedMatch) currentSeed = simpleSeedMatch[1];
            }

            const baseInput = currentBaseInputString;
            let baseHeader = '';
            let baseDynamicParts = [];

            if (baseInput) {
                 const headerMatch = baseInput.match(/^([^\{]*\|\|\s*)/);
                 if (headerMatch) {
                     const headerContent = headerMatch[0].trim();
                     const parts = headerContent.split('||')[0].split('|');
                     if (parts.length === 2) {
                         const firstPart = parts[0].trim();
                         const secondPartParts = parts[1].trim().split(',');
                         if (secondPartParts.length === 2) baseHeader = `${firstPart}| ${secondPartParts[0].trim()}, ${currentSeed}||`;
                         else baseHeader = headerContent;
                     } else baseHeader = headerContent;
                     const remaining = baseInput.substring(headerMatch[0].length).trim();
                     baseDynamicParts = remaining ? remaining.split(/\s+/).filter(p => p.length > 0 && p !== '|') : [];
                 } else {
                     const firstBlockIndex = baseInput.indexOf('{');
                     if (firstBlockIndex === 0) {
                          baseHeader = '';
                          baseDynamicParts = baseInput.split(/\s+/).filter(p => p.length > 0 && p !== '|');
                     } else if (firstBlockIndex > 0) {
                         baseHeader = baseInput.substring(0, firstBlockIndex).trim();
                          const simpleHeaderParts = baseHeader.split('|');
                          if (simpleHeaderParts.length === 2) {
                              const firstPart = simpleHeaderParts[0].trim();
                              const secondPartParts = simpleHeaderParts[1].trim().split(',');
                               if (secondPartParts.length === 2) baseHeader = `${firstPart}| ${secondPartParts[0].trim()}, ${currentSeed}`;
                          }
                         baseDynamicParts = baseInput.substring(firstBlockIndex).trim().split(/\s+/).filter(p => p.length > 0 && p !== '|');
                     } else {
                          baseHeader = baseInput.replace(/\|$/, '').trim(); // Treat as header, remove trailing pipe if present
                          baseDynamicParts = [];
                     }
                }
            } else {
                const typeMap = { gun: 1, shield: 2, grenade: 3, classmod: 4, enhancement: 5 };
                const itemTypeId = typeMap[dom.itemTypeSel?.value] || 0;
                baseHeader = `${itemTypeId}, 0, 1, 50| 2, ${currentSeed}||`;
                const rarityCodeMap = { common: 217, uncommon: 218, rare: 219, epic: 220, legendary: 999 };
                 const rarityPart = `{${rarityCodeMap[dom.raritySel?.value] || 0}}`;
                 if (rarityPart !== '{0}') baseDynamicParts.push(rarityPart);
            }

            const builderPartsRaw = Object.values(builders).flatMap(b => typeof b.getSelectedItems === 'function' ? b.getSelectedItems() : []);
            const builderPartsSet = new Set(builderPartsRaw); // Set of raw added parts like "{X:Y}"

            const allPartsToCondense = [...baseDynamicParts, ...builderPartsRaw];
            const condensedParts = condenseParts(allPartsToCondense); // Array of condensed strings like "{X:[A B]}" or "{Y}"

            // --- Analyze AFTER condensing ---
            const condensedStringForAnalysis = condensedParts.join(' ');
            const duplicates = analyzeDuplicates(condensedStringForAnalysis);

            // --- Build Output HTML with Highlighting ---
            let outputHtml = baseHeader ? baseHeader : ''; // Start with header
            condensedParts.forEach((partStr, index) => {
                 if ((baseHeader || index > 0) && outputHtml.length > 0 && !outputHtml.endsWith(' ')) outputHtml += ' ';

                 const singularMatch = partStr.match(/^\{(\d+)\}$/);
                 const specificMatch = partStr.match(/^\{(\d+):([^\[\]]+)\}$/); // Match only non-array specific parts for specific highlighting
                 const arrayMatch = partStr.match(/^\{(\d+):\[([^\]]+)\]\}$/);

                 if (singularMatch && duplicates.singular[singularMatch[1]]) {
                      outputHtml += `<span class="dup-singular">${partStr}</span>`; // Blue
                 } else if (specificMatch && duplicates.specific[partStr]) {
                      outputHtml += `<span class="dup-specific">${partStr}</span>`; // Orange
                 } else if (arrayMatch) {
                      const id = arrayMatch[1];
                      const values = arrayMatch[2].trim().split(/\s+/);
                      let highlightedValues = values.map(val => {
                           const key = `${id}:${val}`;
                           return duplicates.arrayValues[key] ? `<span class="dup-array-value">${val}</span>` : val; // Yellow for duplicates *within* array
                      }).join(' ');
                      outputHtml += `{${id}:[${highlightedValues}]}`;
                 } else {
                      outputHtml += partStr; // No duplicate or not highlightable type
                 }
            });

            // Add final pipe
            let finalOutputString = outputHtml.replace(/<[^>]*>/g, '');
             if ((baseHeader || condensedParts.length > 0) && !finalOutputString.endsWith('|')) {
                 outputHtml += '|';
             }

            outputHtml = outputHtml.replace(/\s{2,}/g, ' ').replace(/ <span/g, '<span').replace(/span> /g, 'span>').trim();
            lastGeneratedOutput = outputHtml.replace(/<[^>]*>/g, ''); // Store plain text

            if (document.activeElement !== dom.outCode) {
                 dom.outCode.innerHTML = outputHtml;
                 if (isManualEditMode) {
                     isManualEditMode = false;
                     dom.outCode.classList.remove('manual-edit');
                     if (dom.outWrapper) {
                         const indicator = dom.outWrapper.querySelector('.manual-edit-indicator');
                         dom.outWrapper.classList.remove('manual-edit');
                         if(indicator) indicator.style.display = 'none';
                     }
                 }
            }
             // Clear duplicate analysis display on rebuild
             if (dom.duplicateInfoOutput) dom.duplicateInfoOutput.textContent = '';

        } catch (err) {
            showMessage(`Error generating output: <code>${err.message}</code>. Check builder setup and data.`, 'error');
            console.error("Output Generation Error:", err);
            if (dom.outCode) dom.outCode.textContent = '[Error generating output]';
            lastGeneratedOutput = '';
        }
    }


     // --- Debounced Triggers and API Logic ---
     const debouncedRebuild = debounce(rebuildOutputAndCallApi, 50);
     const debouncedApiCall = debounce(callReserialize, 400);

     function triggerDebouncedRebuild() { if (!isManualEditMode) debouncedRebuild(); }
     function triggerDebouncedApiCall() { if (!isManualEditMode) debouncedApiCall(); }
     function rebuildOutputAndCallApi() { rebuildOutput(); triggerDebouncedApiCall(); }

    const API_BASE_URL = 'https://borderlands4-deserializer.nicnl.com/api/v1';

    async function deserializeSerial() {
        const input = dom.baseSerial?.value.trim();
        if (!input) { showMessage('Please enter a serial code in the input box first.', 'error'); return; }
        if (!input.startsWith('@U')) { showMessage('Input does not look like a B85 serial (must start with @U). Cannot deserialize.', 'error'); return; }
        showMessage('Deserializing...', 'info', 2000);
        try {
            const response = await fetch(`${API_BASE_URL}/deserialize_bulk`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify([input]) });
            if (!response.ok) { const errorText = await response.text(); throw new Error(`Deserialize request failed: ${response.status} - ${errorText}`); }
            const result = await response.json(); const firstKey = Object.keys(result)[0];
            if (result[firstKey] && result[firstKey].success !== false && result[firstKey].deserialized) {
                const deserialized = result[firstKey].deserialized;
                if (dom.baseSerial) dom.baseSerial.value = deserialized;
                showMessage('✅ Deserialization successful! Now click "Apply Code Block" to continue.', 'success', 4000);
            } else { throw new Error(result[firstKey]?.error || 'Deserialization failed: API did not return expected data.'); }
        } catch (error) { console.error('Deserialize API Error:', error); showMessage('Deserialization failed: ' + error.message, 'error', 5000); }
    }

    function applyInput() {
        const input = dom.baseSerial?.value.trim();
        if (!input) { showMessage('Input box is empty. Paste a deserialized string or deserialize a @U code first.', 'error'); return; }
        if (input.startsWith('@U')) { showMessage('⚠️ Input looks like a B85 serial! Please click "Deserialize Serial Code" first, then "Apply Code Block".', 'error', 5000); return; }
        const deserializedPattern = /\|\|/; // Basic check
        if (!deserializedPattern.test(input) && !input.includes('|')) {
             showMessage('⚠️ Invalid format! Expected deserialized format containing "||" or at least "|". Please check input or deserialize first.', 'error', 5000);
             return;
        }
        currentBaseInputString = input;
         // Clear all builder selections when applying new base input
         Object.values(builders).forEach(builder => { if (typeof builder.clear === 'function') builder.clear(); });
        showMessage('Input applied successfully. Builders cleared. Rebuilding...', 'success', 2500);
        rebuildOutputAndCallApi(); // Rebuild with cleared builders and trigger API
    }

    async function callReserialize() {
        if (dom.serial_b85) dom.serial_b85.textContent = 'Fetching...';
        if (dom.additionalData) dom.additionalData.textContent = '';
        if (dom.copySerial) dom.copySerial.disabled = true;
        try {
            const outText = (dom.outCode?.textContent || '').trim();
             const isValidSerial = outText.includes('||') && outText.endsWith('|');
             const isJustHeader = !outText.includes('{') && outText.includes('|') && !outText.endsWith('|') || outText.includes('||'); // Header only might lack parts/trailing pipe

             if (!outText || outText === '[Error generating output]' || (!isValidSerial && !isJustHeader)) {
                 if (dom.serial_b85) dom.serial_b85.textContent = '[No valid serial to send]';
                 // Don't show toast for this common case, just update status
                 return;
              }
            const resp = await fetch(`${API_BASE_URL}/reserialize`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ deserialized: outText }) });
            if (!resp.ok) { let errorText = `HTTP ${resp.status} - ${resp.statusText}`; try { const errorData = await resp.json(); errorText += `: ${errorData.error || errorData.message || 'Unknown API error'}`; } catch (_) {} throw new Error(errorText); }
            const data = await resp.json();
            if (dom.serial_b85) dom.serial_b85.textContent = data.serial_b85 || '[No serial returned]';
            if (dom.additionalData) dom.additionalData.textContent = data.additional_data || '[No details]';
            if (dom.copySerial) dom.copySerial.disabled = !data.serial_b85;
        } catch (err) {
            console.error('Reserialize API error:', err);
            if (dom.serial_b85) dom.serial_b85.textContent = `[API error: ${err.message}]`;
            if (dom.additionalData) dom.additionalData.textContent = '';
            if (dom.copySerial) dom.copySerial.disabled = true;
            if (!err.message.includes('aborted')) showMessage(`API Error: ${err.message}`, 'error');
        }
    }

     // --- Generic Selector Tab Logic ---
     function setupGenericSelector() {
         const selectorDataset = document.getElementById('selectorDataset');
         const selectorFilter = document.getElementById('selectorFilter');
         const selectorAvailable = document.getElementById('selectorAvailable');
         const selectorSelected = document.getElementById('selectorSelected');
         const selectorAddBtn = document.getElementById('selectorAddBtn');
         const selectorRemoveBtn = document.getElementById('selectorRemoveBtn');
         const selectorOutput = document.getElementById('selectorOutput');

         if (!selectorDataset || !selectorFilter || !selectorAvailable || !selectorSelected || !selectorAddBtn || !selectorRemoveBtn || !selectorOutput) {
             console.error("Missing elements for Generic Selector tab.");
             return;
         }

         let currentSelectorData = [];
         let currentSelectorSelectedItems = []; // { code: "{X:Y}", uniqueId: number }
         let currentSelectorUniqueId = 0;
         let currentSelectorConfig = {};

         const examplePayload = { // Using example data directly here
            legendaryPerks: [
                { name: "Hellfire", code: "{19:20}" },
                { name: "Seventh Sense", code: "{3:81}" }
                // ... more perks ...
            ],
            enhancementStats: [
                { name: "Damage +10%", code: "{247:1}" },
                { name: "Reload +15%", code: "{247:2}" }
                // ... more stats ...
            ]
         };

         function loadDataset() {
             const key = selectorDataset.value;
             currentSelectorData = examplePayload[key] || []; // Use example payload
             currentSelectorSelectedItems = [];
             currentSelectorUniqueId = 0;
             currentSelectorFilter.value = '';

             // Define how to display and output based on dataset key (customize as needed)
             switch(key) {
                 case 'enhancementStats':
                     currentSelectorConfig = { nameField: 'name', codeField: 'code', outputPrefix: '{247:[', outputSuffix: ']}', outputSeparator: ' ' };
                     break;
                 case 'legendaryPerks':
                 default:
                     currentSelectorConfig = { nameField: 'name', codeField: 'code', outputPrefix: '', outputSuffix: '', outputSeparator: ' ' };
                     break;
             }
             populateSelectorAvailableList();
             updateSelectorSelectedList();
             renderSelectorOutput();
         }

         function populateSelectorAvailableList() {
             selectorAvailable.innerHTML = '';
             const query = selectorFilter.value.toLowerCase();
             const { nameField = 'name', codeField = 'code' } = currentSelectorConfig;

             currentSelectorData
                 .filter(item => {
                     const name = item[nameField] || '';
                     const code = item[codeField] || '';
                     const searchText = `${name} ${code}`.toLowerCase();
                     return !query || searchText.includes(query);
                 })
                 .sort((a, b) => (a[nameField] || '').localeCompare(b[nameField] || ''))
                 .forEach(item => {
                     const o = document.createElement('option');
                     o.value = item[codeField];
                     o.textContent = `${item[nameField]} ${item[codeField]}`;
                     selectorAvailable.appendChild(o);
                 });
         }

          function updateSelectorSelectedList() {
             const scrollState = { top: selectorSelected.scrollTop, left: selectorSelected.scrollLeft };
             const selectedUniqueIds = new Set(Array.from(selectorSelected.selectedOptions).map(opt => opt.value));
             selectorSelected.innerHTML = '';
             const { nameField = 'name' } = currentSelectorConfig;

             currentSelectorSelectedItems.forEach(item => {
                 const name = currentSelectorData.find(d => d[currentSelectorConfig.codeField] === item.code)?.[nameField] || 'Unknown';
                 const o = document.createElement('option');
                 o.value = item.uniqueId.toString();
                 o.textContent = `${name} ${item.code}`;
                 o.dataset.code = item.code;
                 if (selectedUniqueIds.has(o.value)) o.selected = true;
                 selectorSelected.appendChild(o);
             });
             selectorSelected.scrollTop = scrollState.top; selectorSelected.scrollLeft = scrollState.left;
         }


         function handleSelectorAdd() {
             Array.from(selectorAvailable.selectedOptions).forEach(opt => {
                 currentSelectorSelectedItems.push({ code: opt.value, uniqueId: currentSelectorUniqueId++ });
             });
             updateSelectorSelectedList();
             renderSelectorOutput();
         }

         function handleSelectorRemove() {
             const idsToRemove = new Set(Array.from(selectorSelected.selectedOptions).map(opt => parseInt(opt.value, 10)));
             if (idsToRemove.size === 0) return;
             currentSelectorSelectedItems = currentSelectorSelectedItems.filter(item => !idsToRemove.has(item.uniqueId));
             updateSelectorSelectedList();
             renderSelectorOutput();
         }

         function renderSelectorOutput() {
             const { outputPrefix = '', outputSuffix = '', outputSeparator = ' ' } = currentSelectorConfig;
             const codes = currentSelectorSelectedItems.map(item => item.code);

             if (outputPrefix === '{247:[') { // Special condense for 247
                 const uniqueCodes = [...new Set(codes.map(c => c.match(/\d+/)?.[0]).filter(Boolean))]; // Extract numbers
                 selectorOutput.textContent = uniqueCodes.length > 0 ? `${outputPrefix}${uniqueCodes.join(outputSeparator)}${outputSuffix}` : '';
             } else {
                 selectorOutput.textContent = codes.length > 0 ? `${outputPrefix}${codes.join(outputSeparator)}${outputSuffix}` : '';
             }
         }

         selectorDataset.addEventListener('change', loadDataset);
         selectorFilter.addEventListener('input', debounce(populateSelectorAvailableList, 200));
         selectorAddBtn.addEventListener('click', handleSelectorAdd);
         selectorRemoveBtn.addEventListener('click', handleSelectorRemove);
         selectorAvailable.addEventListener('dblclick', handleSelectorAdd);
         selectorSelected.addEventListener('dblclick', handleSelectorRemove);
         selectorSelected.addEventListener('keydown', e => { if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); handleSelectorRemove(); } });

         loadDataset(); // Initial load
     }

      // --- Tab Switching Logic ---
      function setupTabs() {
        const tabLinks = document.querySelectorAll('.tab-link');
        const tabContents = document.querySelectorAll('.tab-content');

        tabLinks.forEach(link => {
            link.addEventListener('click', () => {
                const tabId = link.getAttribute('data-tab');

                // Deactivate all links and contents
                tabLinks.forEach(l => l.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));

                // Activate the clicked link and corresponding content
                link.classList.add('active');
                const activeContent = document.getElementById(tabId);
                if (activeContent) {
                    activeContent.classList.add('active');
                } else {
                    console.error("Tab content not found for ID:", tabId);
                }
            });
        });
     }


    // --- Initialization ---
    async function initializeApp() {
        currentBaseInputString = '';
        PAYLOAD = {};

        try {
            // --- Fetch parts data with error handling ---
            try {
                const response = await fetch('bl4_parts_data.json');
                if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                PAYLOAD = await response.json();
                console.log("Successfully loaded bl4_parts_data.json");
            } catch (fetchError) {
                console.warn(`Could not load or parse bl4_parts_data.json: ${fetchError.message}. Builders relying on this data will be empty.`);
                showMessage(`Warning: Failed to load parts data (bl4_parts_data.json). Some builders will be empty. Error: ${fetchError.message}`, 'error', 8000);
                PAYLOAD = {}; // Ensure PAYLOAD is empty on failure
            }

            // --- Initialize Builders ---
            document.querySelectorAll('.builderSection').forEach(section => {
                 const key = section.dataset.key;
                 const nameField = section.dataset.nameField;
                 const codeField = section.dataset.codeField;
                 const idPrefix = section.dataset.idPrefix;
                 if (key && nameField && codeField && idPrefix && PAYLOAD[key]) {
                     try { builders[key] = createBuilder(key, nameField, codeField, idPrefix); }
                     catch (builderError) { console.error(`Failed to init builder for ${key}: ${builderError.message}`); showMessage(`Error initializing builder "${key}": ${builderError.message}`, 'error', 6000); }
                 } else if (key && nameField && codeField && idPrefix) { console.warn(`Skipping builder section "${key}", missing data in PAYLOAD.`); }
                 else { console.warn("Skipping builder section, missing data-attributes:", section); }
            });

            // --- Setup Event Listeners ---
            if (dom.itemTypeSel) dom.itemTypeSel.addEventListener('change', triggerDebouncedRebuild);
            if (dom.raritySel) dom.raritySel.addEventListener('change', triggerDebouncedRebuild);
            if (dom.applyInputBtn) dom.applyInputBtn.addEventListener('click', applyInput);
            if (dom.deserializeBtn) dom.deserializeBtn.addEventListener('click', deserializeSerial);
            if (dom.analyzeDuplicatesBtn) dom.analyzeDuplicatesBtn.addEventListener('click', analyzeAndDisplayDuplicates); // Listener for new button

            if (dom.outCode) dom.outCode.addEventListener('input', () => {
                isManualEditMode = true; dom.outCode.classList.add('manual-edit');
                if (dom.outWrapper) {
                     const indicator = dom.outWrapper.querySelector('.manual-edit-indicator');
                     dom.outWrapper.classList.add('manual-edit'); if(indicator) indicator.style.display = 'inline';
                 }
                clearTimeout(apiCallTimer); clearTimeout(rebuildTimer); // Stop auto updates/calls
            });

            if (dom.undoEditBtn) dom.undoEditBtn.addEventListener('click', () => {
                 if (lastGeneratedOutput) {
                     isManualEditMode = false;
                     currentBaseInputString = lastGeneratedOutput; // Restore plain text used by rebuild
                     rebuildOutput(); // Rebuild to regenerate HTML highlighting & clear duplicate info
                     if (dom.outCode) dom.outCode.classList.remove('manual-edit');
                     if (dom.outWrapper) {
                         const indicator = dom.outWrapper.querySelector('.manual-edit-indicator');
                         dom.outWrapper.classList.remove('manual-edit'); if(indicator) indicator.style.display = 'none';
                     }
                     triggerDebouncedApiCall(); // Resume API calls
                     showCopyStatus(dom.copyFullStatus, 'Edit Undone');
                 } else { showCopyStatus(dom.copyFullStatus, 'No history!'); }
             });

            if (dom.reserializeManualBtn) dom.reserializeManualBtn.addEventListener('click', callReserialize);

            // Copy Buttons (using execCommand for potential iframe compatibility)
             if (dom.copyFull) dom.copyFull.addEventListener('click', () => {
                 const text = (dom.outCode?.textContent || '').trim();
                 if (!text || text.startsWith('[')) return showMessage('No output to copy!', 'error');
                 const textArea = document.createElement("textarea");
                 textArea.value = text;
                 document.body.appendChild(textArea);
                 textArea.select();
                 try { document.execCommand('copy'); showCopyStatus(dom.copyFullStatus, 'Copied!'); }
                 catch (err) { console.error('Copy Output failed:', err); showMessage('Copy failed!', 'error'); }
                 document.body.removeChild(textArea);
             });
             if (dom.copySerial) dom.copySerial.addEventListener('click', () => {
                 const text = (dom.serial_b85?.textContent || '').trim();
                  if (!text || text.startsWith('[')) return showMessage('No API serial to copy!', 'error');
                  const textArea = document.createElement("textarea");
                  textArea.value = text;
                  document.body.appendChild(textArea);
                  textArea.select();
                  try { document.execCommand('copy'); showCopyStatus(dom.copyApiStatus, 'Copied!'); }
                  catch (err) { console.error('Copy API Serial failed:', err); showMessage('Copy failed!', 'error'); }
                  document.body.removeChild(textArea);
              });


             setupCollapsibleSections();
             setupTabs(); // Initialize tab switching
             setupGenericSelector(); // Initialize the generic selector tab
             rebuildOutput();
             setTimeout(callReserialize, 150);

        } catch (error) {
            showMessage(`Critical Initialization failed: ${error.message}`, 'error', 10000);
            console.error("Critical Initialization error:", error);
            document.querySelectorAll('input, select, button, [contenteditable]').forEach(el => { if(el) el.disabled = true; });
            if (dom.baseSerial) dom.baseSerial.disabled = true;
            if (dom.outCode) dom.outCode.contentEditable = false;
        }
    }

    // --- DOM Ready ---
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp();
    }
</script>
</body>
</html>

