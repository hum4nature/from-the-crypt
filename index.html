<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport"/>
    <title>BL4 Decoder & Generic Selector</title>
    <!-- Using Tailwind CSS for rapid UI development -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles adapted from Enhancement_Editor.html */
        :root {
            --bg: #0b0f14;
            --card: #0e1520;
            --ink: #e6f0ff;
            --muted: #a6b4c8;
            --line: #1f2a3a;
            --accent-orange: #e59400;
            --danger-red: #e74c3c;
            --success-green: #28a745;
            --edit-yellow: #ffc107;
        }
        * { box-sizing: border-box; }
        body { font-family: 'Inter', system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--bg); color: var(--ink); font-size: 16px; line-height: 1.5; margin: 0; }

        /* --- TAB NAVIGATION STYLES --- */
        .tab-nav { background-color: var(--card); border-bottom: 1px solid var(--line); padding: 0 18px; margin-bottom: 18px; display: flex; gap: 10px; }
        .tab-link { display: inline-block; padding: 12px 16px; border: none; background: none; color: var(--muted); cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s ease; font-size: 1rem; }
        .tab-link.active { color: var(--ink); border-bottom-color: var(--accent-orange); }
        .tab-link:hover { color: var(--ink); }
        .tab-content { display: none; padding: 0 18px; /* Padding for content */ }
        .tab-content.active { display: block; }

        /* --- General Component Styles --- */
        .card { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 16px; margin-bottom: 18px; }
        label { color: var(--muted); font-size: 12px; display: block; margin-bottom: 6px; }
        select, input[type="text"], input[type="number"], textarea, button { background: #0f1720; color: var(--ink); border: 1px solid var(--line); border-radius: 10px; padding: 10px 12px; font-size: 1rem; transition: border-color 0.2s ease; }
        select:focus, input:focus, textarea:focus, button:focus { outline: none; border-color: var(--accent-orange); }
        select[multiple] { min-height: 150px; }
        button { cursor: pointer; background: #1f2a3a; transition: background-color 0.2s ease; }
        button:hover { background: #2a3a4a; }
        button.primary { background: var(--accent-orange); color: var(--bg); }
        button.primary:hover { background: #ffae1a; }
        button.small { padding: 6px 10px; border-radius: 8px; font-size: 0.9rem; }
        code, pre { background: #0c121b; border: 1px solid var(--line); padding: 8px 10px; border-radius: 8px; font-family: 'Courier New', Courier, monospace; word-wrap: break-word; white-space: pre-wrap; color: var(--muted); }
        pre { max-height: 300px; overflow-y: auto; }
        .output-code { min-height: 50px; cursor: text; }

        /* Layout Helpers */
        .grid-cols-auto { grid-template-columns: auto 1fr; }
        .grid-cols-fr-auto-fr { grid-template-columns: 1fr auto 1fr; }

        /* Collapsible Sections */
        .collapsible-header { cursor: pointer; padding: 10px; background: #1a2433; border-radius: 8px; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
        .collapsible-header:hover { background: #202b3d; }
        .collapsible-content { padding: 10px; border: 1px solid var(--line); border-radius: 8px; border-top-left-radius: 0; border-top-right-radius: 0; margin-top: -5px; display: none; }
        .collapsible-content.open { display: block; }
        .collapsible-arrow { transition: transform 0.3s ease; }
        .collapsible-header.open .collapsible-arrow { transform: rotate(90deg); }

        /* Message Area */
        #messageArea { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: var(--card); color: var(--ink); padding: 10px 20px; border-radius: 8px; border: 1px solid var(--line); z-index: 1000; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; }
        #messageArea.show { opacity: 1; }
        #messageArea.error { background-color: var(--danger-red); color: white; border-color: darkred; }
        #messageArea.success { background-color: var(--success-green); color: white; border-color: darkgreen; }
        #messageArea.warning { background-color: var(--edit-yellow); color: black; border-color: orange; }

        /* Selector List Box Specific Styles */
        .selector-box select { width: 100%; }
        .selector-buttons { display: flex; flex-direction: column; justify-content: center; gap: 10px; padding: 0 10px; }

        /* Disabled state */
        input:disabled, select:disabled, textarea:disabled, button:disabled { opacity: 0.6; cursor: not-allowed; background: #1a2433; }
        [contenteditable="false"] { opacity: 0.6; cursor: not-allowed; background: #1a2433; }

        /* --- Style for Added Parts --- */
        .added-part {
            color: var(--success-green);
            font-weight: 500; /* Slightly bolder */
        }
        /* --- END NEW Style --- */

        /* --- Style for Duplicate Info --- */
        #duplicateInfoContainer {
            margin-top: 10px;
        }
        #duplicateInfoOutput {
            font-size: 12px;
            color: var(--muted);
            margin-top: 5px;
            white-space: normal; /* Allow wrapping */
            word-break: break-all; /* Break long strings if needed */
            line-height: 1.4;
        }
        /* --- END Duplicate Info Style --- */

        /* --- Styles for Duplicate Highlighting --- */
        .dup-singular {
            color: #3498db; /* Blue */
            font-weight: 500;
        }
        .dup-specific {
            color: #e67e22; /* Orange */
            font-weight: 500;
        }
        .dup-array-value {
            color: #f1c40f; /* Yellow */
            background-color: rgba(241, 196, 15, 0.1); /* Slight yellow background */
            padding: 0 2px;
            border-radius: 3px;
            font-weight: 500;
        }
        /* --- END Duplicate Highlighting Styles --- */
    </style>
</head>
<body>

    <!-- Tab Navigation -->
    <nav class="tab-nav">
        <button class="tab-link active" data-tab="decoder">Decoder/Editor</button>
        <button class="tab-link" data-tab="selector">Generic Selector</button>
        <button class="tab-link" data-tab="api">API Info</button>
    </nav>

    <!-- Tab Content -->
    <div id="decoder" class="tab-content active">
        <div class="card grid grid-cols-1 md:grid-cols-2 gap-4">
            <!-- Serial Input -->
            <div>
                <label for="serialOutputCode">Edit Serial Code:</label>
                <div id="serialOutputCode" contenteditable="true" class="output-code p-2 border border-gray-600 rounded-md bg-gray-900 min-h-[100px]" spellcheck="false">15, 0, 1, 50| 2, 2303|| {98} {75} {2} {6} {1:12} {66} {72} {14} {27} {35} {34} {41} {58} {28} {7} {18} {12} {12} {12}</div>
                <div class="mt-2 flex gap-2">
                     <button id="rebuildAndCallApiBtn" class="primary small">Generate Serial String (Manual)</button>
                     <button id="copyFull" class="small">Copy Output</button>
                </div>
            </div>
             <!-- API Results -->
             <div>
                 <div>
                     <label for="apiSerialOutput">New Serial (from API):</label>
                     <pre id="apiSerialOutput">[API results will appear here]</pre>
                     <button id="copySerial" class="small mt-1">Copy API Serial</button>
                 </div>
                 <div class="mt-4">
                     <label for="detailsOutput">Details (from API):</label>
                     <pre id="detailsOutput" class="text-xs">[Deserialized details will appear here]</pre>
                 </div>
             </div>
        </div>

         <!-- Collapsible Sections for Parts -->
         <div id="partSelectorsContainer">
            <!-- Sections will be dynamically added here -->
         </div>

         <!-- Decoded Output Section -->
         <div class="card mt-4">
            <h2 class="text-xl font-semibold mb-2">Decoded Blocks</h2>
            <div id="decodedOutput" class="space-y-1 text-sm">
                <!-- Decoded parts will appear here -->
            </div>
         </div>
    </div>

    <div id="selector" class="tab-content">
        <div class="card">
            <h2 class="text-xl font-semibold mb-3">Generic Part Selector</h2>
            <div class="mb-4">
                <label for="datasetSelector">Select Dataset:</label>
                <select id="datasetSelector" class="w-full md:w-1/3">
                    <!-- Options added dynamically -->
                     <option value="legendaryPerks">Legendary Perks (Example)</option>
                     <option value="enhancementStats">Enhancement Stats (Example)</option>
                </select>
            </div>

            <div class="grid grid-cols-fr-auto-fr gap-4 items-start selector-box">
                <!-- Available List -->
                <div>
                    <label for="selectorAvailableList">Available:</label>
                    <select id="selectorAvailableList" multiple></select>
                </div>

                <!-- Add/Remove Buttons -->
                <div class="selector-buttons">
                    <button id="selectorAddBtn" class="small">→</button>
                    <button id="selectorRemoveBtn" class="small">←</button>
                </div>

                <!-- Selected List -->
                <div>
                    <label for="selectorSelectedList">Selected:</label>
                    <select id="selectorSelectedList" multiple></select>
                </div>
            </div>

             <!-- Output Area -->
             <div class="mt-4">
                <label for="selectorOutput">Generated Output:</label>
                <pre id="selectorOutput">[Select items to generate output]</pre>
                 <button id="copySelectorOutputBtn" class="small mt-1">Copy Selector Output</button>
             </div>
        </div>
    </div>

    <div id="api" class="tab-content">
         <div class="card">
             <h2 class="text-xl font-semibold mb-3">API Information</h2>
             <p>Endpoint: <code class="text-sm">https://borderlands4-deserializer.nicnl.com/api/v1/reserialize</code></p>
             <p class="mt-2">Method: <code class="text-sm">POST</code></p>
             <p class="mt-2">Content-Type: <code class="text-sm">application/json</code></p>
             <p class="mt-2">Request Body Example:</p>
             <pre class="text-xs">{ "deserialized": "15, 0, 1, 50| 2, 2303|| {98} ..." }</pre>
             <p class="mt-2">The API is called automatically when the 'Edit Serial Code' field is modified (debounced) or when 'Generate Serial String (Manual)' is clicked.</p>
         </div>
    </div>

    <!-- Message Area -->
    <div id="messageArea"></div>

<script>
(function() {
    'use strict';

    // --- Configuration & Constants ---
    const API_ENDPOINT = 'https://borderlands4-deserializer.nicnl.com/api/v1/reserialize';
    const API_DEBOUNCE_MS = 400;

    // --- DOM Element References ---
    const dom = {
        serialOutputCode: document.getElementById('serialOutputCode'),
        apiSerialOutput: document.getElementById('apiSerialOutput'),
        detailsOutput: document.getElementById('detailsOutput'),
        rebuildAndCallApiBtn: document.getElementById('rebuildAndCallApiBtn'),
        copyFull: document.getElementById('copyFull'),
        copySerial: document.getElementById('copySerial'),
        partSelectorsContainer: document.getElementById('partSelectorsContainer'),
        decodedOutput: document.getElementById('decodedOutput'),
        messageArea: document.getElementById('messageArea'),
        // Generic Selector Elements
        datasetSelector: document.getElementById('datasetSelector'),
        selectorAvailableList: document.getElementById('selectorAvailableList'),
        selectorSelectedList: document.getElementById('selectorSelectedList'),
        selectorAddBtn: document.getElementById('selectorAddBtn'),
        selectorRemoveBtn: document.getElementById('selectorRemoveBtn'),
        selectorOutput: document.getElementById('selectorOutput'),
        copySelectorOutputBtn: document.getElementById('copySelectorOutputBtn'),
        // Tabs
        tabLinks: document.querySelectorAll('.tab-link'),
        tabContents: document.querySelectorAll('.tab-content'),
        // Output section elements for duplicate highlighting/analysis
        outWrapper: document.querySelector('.outCard'), // The card containing the output
        outCode: document.getElementById('out')?.querySelector('code'),
        analyzeDuplicatesBtn: document.getElementById('analyzeDuplicatesBtn'),
        duplicateInfoOutput: document.getElementById('duplicateInfoOutput'),
        // Input elements needed for rebuilding
        baseSerialInput: document.getElementById('baseSerial'),
        itemTypeSel: document.getElementById('itemType'), // Assuming IDs exist
        raritySel: document.getElementById('rarity'), // Assuming IDs exist
        applyInputBtn: document.getElementById('applyInputBtn'),
        deserializeBtn: document.getElementById('deserializeBtn'),
        reserializeManualBtn: document.getElementById('reserializeManual'),
        undoEditBtn: document.getElementById('undoEdit'),
        copyFullStatus: document.getElementById('copyFullStatus'),
        serial_b85: document.getElementById('serial_b85') // For API copy
    };

    // --- State Variables ---
    let apiAbortController = null;
    let apiDebounceTimeout = null;
    let messageTimeout = null;
    let selectorSelectedItems = []; // Array to hold selected items with duplicates for the generic selector
    let currentSelectorDatasetKey = 'legendaryPerks'; // Default dataset key
    let PAYLOAD = {}; // Will be loaded async
    const builders = {}; // Will hold builder instances
    let lastGeneratedOutput = '';
    let isManualEditMode = false;
    let currentBaseInputString = ''; // Store the applied base input

    // --- Utility Functions (Moved Up) ---
    function showMessage(text, type = 'info', duration = 3000) {
        if (!dom.messageArea) { console.warn("Message area not found, cannot show:", text); return; } // Add check
        if (messageTimeout) clearTimeout(messageTimeout);
        // Use innerHTML to allow basic tags like <code>
        dom.messageArea.innerHTML = text; // Changed from textContent
        dom.messageArea.className = `show ${type}`; // Add type class (error, success, warning)
        messageTimeout = setTimeout(() => {
            if (dom.messageArea) dom.messageArea.className = ''; // Remove 'show' and type class
        }, duration);
    }

    // Debounce function
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

     // --- Show Copy Status (Moved Up, was inline before) ---
     function showCopyStatus(el, msg) {
         if (!el) return;
         el.textContent = msg;
         setTimeout(() => el.textContent = '', 1200);
     }


    // --- Core Data Structures (Parts & Lookups) ---
    // Example PAYLOAD structure matching reference files
    const EXAMPLE_PAYLOAD = {
        legendaryPerks: [
             { name: "God Killer", group: "Firmware", code: "244:1", variant: "Firm" },
             { name: "Reel Big Fist", group: "Firmware", code: "244:2", variant: "Firm" },
             { name: "Lifeblood", group: "Firmware", code: "244:3", variant: "Firm" },
             { name: "Airstrike", group: "Firmware", code: "244:4", variant: "Firm" },
             { name: "High Caliber", group: "Firmware", code: "244:5", variant: "Firm" },
        ],
        enhancementStats: [
             { text: "Acc +75%", value: 168 }, { text: "ADS +75%", value: 169 },
             { text: "Crit DMG +75%", value: 170 }, { text: "DMG +38%", value: 171 },
             { text: "Equip +150%", value: 172 }, { text: "Fire Rate +38%", value: 173 },
             { text: "Mag +75%", value: 174 }, { text: "Reload +38%", value: 175 },
        ],
    };

    // --- PART DATA FOR DECODER/EDITOR ---
    // Simplified structure based on index (12).html for brevity
    const PARTS_DATA = {
        itemInfo: [{ text: "Item Level", value: "level", type: "number", min: 1, max: 99 }, ],
        core: [{ text: "Item Type / Manufacturer", value: "itemType" }], // Dynamically populated
        elements: [
            { text: "No Element", value: "" }, { text: "Corrosive", value: "{1:10}" },
            { text: "Cryo", value: "{1:11}" }, { text: "Incendiary", value: "{1:12}" },
            { text: "Radiation", value: "{1:13}" }, { text: "Shock", value: "{1:14}" },
        ],
        legendaryPerks: [], // To be populated from PAYLOAD
        ordnancePerks: [
              {text: "No Ordnance Perk", value: ""}, {text: "Whistler {282:25}", value: "{282:25}"},
        ]
    };

    // Combine all selectable parts into one array for easier processing
    let ALL_SELECTABLE_PARTS = []; // Will be built after PAYLOAD load

    // --- Lookup Maps for Decoding ---
    const genericParts = {}; // For {ID} blocks
    const specificParts = {}; // For {X:Y} blocks

    function buildLookupMapsAndPartData() {
        // Populate PARTS_DATA from loaded PAYLOAD
        PARTS_DATA.legendaryPerks = (PAYLOAD.legendaryPerks || []).map(p => ({ text: p.name, value: `{${p.code}}` }));
        // Add similar mappings for other parts from PAYLOAD (e.g., altFireModes, magazineModes)

        ALL_SELECTABLE_PARTS = Object.values(PARTS_DATA).flat();

        // Build Lookups
        genericParts = {}; // Clear previous
        specificParts = {}; // Clear previous

        ALL_SELECTABLE_PARTS.forEach(part => {
             if (!part || !part.value) return; // Skip empty/invalid

             const genericMatch = part.value.match(/^\{(\d+)\}$/);
             const specificMatch = part.value.match(/^\{(\d+:\d+)\}$/); // Match {X:Y}

             if (genericMatch) {
                 genericParts[genericMatch[1]] = part.text;
             } else if (specificMatch) {
                 specificParts[specificMatch[1]] = part.text;
             }
        });
         // Add firmware and other known blocks
         genericParts['ft'] = 'Firmware Lock'; genericParts['c'] = 'Skin/Color';
         (PAYLOAD.enhancementStats || []).forEach(stat => {
            specificParts[`247:${stat.value}`] = `Enhancement: ${stat.text}`;
         });

         console.log("Built Generic Parts Lookup:", genericParts);
         console.log("Built Specific Parts Lookup:", specificParts);
    }


    // --- API Call Logic ---
    const callReserialize = async () => {
        if (!dom.serialOutputCode || !dom.apiSerialOutput || !dom.detailsOutput) return; // Check DOM elements
        if (apiAbortController) apiAbortController.abort();
        apiAbortController = new AbortController();
        const signal = apiAbortController.signal;

        const deserializedString = (dom.serialOutputCode.textContent || '').trim();
        if (!deserializedString) {
            dom.apiSerialOutput.textContent = '[Input serial code above]';
            dom.detailsOutput.textContent = '[Input serial code above]';
            return;
        }

        dom.apiSerialOutput.textContent = '[Calling API...]';
        dom.detailsOutput.textContent = '[Calling API...]';

        try {
            const response = await fetch(API_ENDPOINT, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ deserialized: deserializedString }), signal: signal,
            });
            if (!response.ok) {
                const errorData = await response.text();
                throw new Error(`API Error ${response.status}: ${errorData || response.statusText}`);
            }
            const data = await response.json();
            dom.apiSerialOutput.textContent = data?.serial_b85 || '[No serial returned]';
            dom.detailsOutput.textContent = JSON.stringify(data?.additional_data || {}, null, 2);
        } catch (error) {
             if (error.name === 'AbortError') { console.log('API request aborted (debounced)'); return; }
            console.error('API call failed:', error);
            const errorMessage = `API Call Failed: ${error.message}`;
            dom.apiSerialOutput.textContent = `[${errorMessage}]`;
            dom.detailsOutput.textContent = `[${errorMessage}]`;
             showMessage(errorMessage, 'error', 5000);
        } finally {
            apiAbortController = null;
        }
    };
    const debouncedApiCall = debounce(callReserialize, API_DEBOUNCE_MS);

    // --- Serial Parsing & Decoding Logic ---
    function parseSerialString(serial) { /* ... function unchanged ... */
        if (!serial) return { header: [], blocks: [] };
        const parts = serial.split('||');
        if (parts.length < 2) return { header: [], blocks: [] }; // Basic validation

        const headerPart = parts[0].trim();
        const blocksPart = parts[1].trim();

        // Parse header (simple split for now, might need refinement)
        const header = headerPart.split('|').map(s => s.trim());

        // Parse blocks: handles {X}, {X:Y}, {X:[A B C]}, "ft", "c"
        const blockRegex = /\{(\d+)(?::(\d+|\[[\d\s]+\]))?\}|("?[a-zA-Z]+"?)/g;
        const blocks = [];
        let match;
        while ((match = blockRegex.exec(blocksPart)) !== null) {
            if (match[3]) { // Quoted string like "ft" or "c"
                blocks.push({ raw: match[3].replace(/"/g, ''), type: 'string' });
            } else if (match[2]) { // Has colon: {X:Y} or {X:[A B C]}
                const id = match[1];
                const valuePart = match[2];
                if (valuePart.startsWith('[')) { // Array block
                    const values = valuePart.slice(1, -1).trim().split(/\s+/).map(Number);
                    blocks.push({ id, values, raw: match[0], type: 'array' });
                } else { // Specific block {X:Y}
                    blocks.push({ id, value: parseInt(valuePart, 10), raw: match[0], type: 'specific' });
                }
            } else { // Generic block {X}
                blocks.push({ id: match[1], raw: match[0], type: 'generic' });
            }
        }
        return { header, blocks };
    }
     function decodeBlocks(parsedSerial) { /* ... function unchanged ... */
         return parsedSerial.blocks.map(block => {
             let name = `Unknown (${block.raw})`;
             let details = '';

             try {
                 if (block.type === 'string') {
                     name = genericParts[block.raw] || `Unknown String (${block.raw})`;
                 } else if (block.type === 'generic') {
                     name = genericParts[block.id] || `Unknown Generic (${block.raw})`;
                 } else if (block.type === 'specific') {
                     const key = `${block.id}:${block.value}`;
                     name = specificParts[key] || `Unknown Specific (${block.raw})`;
                 } else if (block.type === 'array') {
                     name = genericParts[block.id] || `Unknown Array Block (${block.id})`;
                     // Try decoding individual values if they are known specific parts within this block ID context
                      const decodedValues = block.values.map(val => {
                         const key = `${block.id}:${val}`;
                         return specificParts[key] || `val ${val}`; // Show known name or just the value
                      });
                     details = `[${decodedValues.join(', ')}]`;
                      // Special case for enhancement block (247)
                      if (block.id === '247') {
                           name = 'Enhancement Stats';
                           const statValues = block.values.map(val => specificParts[`247:${val}`] || `Unknown Stat (${val})`);
                           details = `[${statValues.join(' | ')}]`;
                      }
                 }
             } catch (e) {
                 console.error("Error decoding block:", block, e);
                 name = `Error Decoding (${block.raw})`;
             }

             return { raw: block.raw, name, details };
         });
     }
     function renderBlocks(decodedData) { /* ... function unchanged ... */
         if (!dom.decodedOutput) return;
         dom.decodedOutput.innerHTML = decodedData.map(d => `
             <div>
                 <code>${d.raw}</code>: ${d.name} ${d.details ? `<span class="text-gray-400 text-xs">${d.details}</span>` : ''}
             </div>
         `).join('');
     }

    // --- Serial Building Logic ---
    function rebuildOutput() { /* ... function unchanged ... */
        if (!dom.serialOutputCode) return; // Add check
        try {
             let currentSeed = '1234'; // Default placeholder
             const headerMatchSeed = currentBaseInputString.match(/\|\s*\d+,\s*(\d+)\|\|/);
             if (headerMatchSeed) {
                 currentSeed = headerMatchSeed[1];
             }

            const baseInput = currentBaseInputString; // Read from global var
            let baseHeader = '';
            let baseDynamicParts = []; // Parts parsed FROM the base input string

            // 1. Parse Base Input
            if (baseInput) {
                const headerMatch = baseInput.match(/^([^\{]*\|\|\s*)/);
                 const seedMatch = baseInput.match(/\|\s*\d+,\s*(\d+)\|\|/);
                 if (seedMatch) currentSeed = seedMatch[1];

                if (headerMatch) {
                    const headerParts = headerMatch[0].trim().split('||')[0].split('|');
                     if (headerParts.length === 2) {
                         const firstPart = headerParts[0].trim();
                         const secondPartParts = headerParts[1].trim().split(',');
                         if (secondPartParts.length === 2) {
                             baseHeader = `${firstPart}| ${secondPartParts[0].trim()}, ${currentSeed}||`;
                         } else { baseHeader = headerMatch[0].trim(); }
                     } else { baseHeader = headerMatch[0].trim(); }
                    const remaining = baseInput.substring(headerMatch[0].length).trim();
                    baseDynamicParts = remaining ? remaining.split(/\s+/).filter(p => p.length > 0) : [];
                } else {
                     const firstBlockIndex = baseInput.indexOf('{');
                     if (firstBlockIndex === 0) { baseHeader = ''; baseDynamicParts = baseInput.split(/\s+/).filter(p => p.length > 0); }
                     else if (firstBlockIndex > 0) {
                         baseHeader = baseInput.substring(0, firstBlockIndex).trim();
                          const simpleHeaderParts = baseHeader.split('|');
                          if (simpleHeaderParts.length === 2) {
                              const firstPart = simpleHeaderParts[0].trim();
                              const secondPartParts = simpleHeaderParts[1].trim().split(',');
                               if (secondPartParts.length === 2) { baseHeader = `${firstPart}| ${secondPartParts[0].trim()}, ${currentSeed}`; }
                          }
                         baseDynamicParts = baseInput.substring(firstBlockIndex).trim().split(/\s+/).filter(p => p.length > 0);
                     }
                     else { baseHeader = baseInput; baseDynamicParts = []; }
                }
            } else { // Generate Base Header if no input
                // Requires dom.itemTypeSel and dom.raritySel to be defined
                const itemTypeId = dom.itemTypeSel ? ({"gun": 1, "shield": 2, "grenade": 3, "classmod": 4, "enhancement": 5})[dom.itemTypeSel.value] || 0 : 0;
                 baseHeader = `${itemTypeId}, 0, 1, 50| 2, ${currentSeed}||`;
                 const rarityCode = dom.raritySel ? ({"common": 217, "uncommon": 218, "rare": 219, "epic": 220, "legendary": 999})[dom.raritySel.value] || 0 : 0;
                 if (rarityCode) baseDynamicParts.push(`{${rarityCode}}`);
            }

            // 2. Collect parts from ALL builders
            const builderPartsRaw = [];
            Object.values(builders).forEach(builder => {
                if (typeof builder.getSelectedItems === 'function') {
                    builderPartsRaw.push(...builder.getSelectedItems());
                }
            });
            const builderPartsSet = new Set(builderPartsRaw);

            // 3. Combine and Condense
            // NOTE: Condense logic needs to be defined
            // const allPartsToCondense = [...baseDynamicParts, ...builderPartsRaw];
            // const condensedParts = condenseParts(allPartsToCondense); // Assuming condenseParts exists
            const condensedParts = [...baseDynamicParts, ...builderPartsRaw]; // Placeholder without condense

            // 3.5 Analyze Condensed Parts for Duplicates
             const tempSerialForAnalysis = baseHeader + ' ' + condensedParts.join(' ');
             const analysis = analyzeDuplicates(tempSerialForAnalysis);
             const duplicateSingularSet = new Set(analysis.duplicates.singular);
             const duplicateSpecificSet = new Set(analysis.duplicates.specific);
             const duplicateArrayValueSet = new Set(analysis.duplicates.arrayValues);

            // 4. Build Output HTML with highlighting
            let outputHtml = '';
            if (baseHeader) outputHtml += baseHeader;

            condensedParts.forEach((partStr, index) => {
                let isAdded = false; let highlightClass = ''; let processedPartStr = partStr;
                 const arrayMatch = partStr.match(/^\{(\d+):\s*\[([^\]]+)\]\s*\}$/);
                 if (arrayMatch) {
                     const id = arrayMatch[1]; const values = arrayMatch[2].trim().split(/\s+/);
                     isAdded = values.some(val => builderPartsSet.has(`{${id}:${val}}`)) || builderPartsSet.has(`{${id}}`);
                     const highlightedValues = values.map(val => duplicateArrayValueSet.has(`${id}-${val}`) ? `<span class="dup-array-value">${val}</span>` : val);
                     processedPartStr = `{${id}:[${highlightedValues.join(' ')}]}`;
                 } else {
                     isAdded = builderPartsSet.has(partStr);
                      const singularMatch = partStr.match(/^\{(\d+)\}$/);
                      const specificMatch = partStr.match(/^\{(\d+:\d+)\}$/);
                      if (singularMatch && duplicateSingularSet.has(singularMatch[1])) highlightClass = 'dup-singular';
                      else if (specificMatch && duplicateSpecificSet.has(specificMatch[1])) highlightClass = 'dup-specific';
                 }
                if ((baseHeader || index > 0) && outputHtml.length > 0 && !outputHtml.endsWith(' ')) outputHtml += ' ';
                const addedSpanStart = isAdded ? '<span class="added-part">' : ''; const addedSpanEnd = isAdded ? '</span>' : '';
                const dupSpanStart = highlightClass ? `<span class="${highlightClass}">` : ''; const dupSpanEnd = highlightClass ? '</span>' : '';
                outputHtml += `${addedSpanStart}${dupSpanStart}${processedPartStr}${dupSpanEnd}${addedSpanEnd}`;
            });

            // 5. Add final pipe and clean up
            let finalOutputString = outputHtml.replace(/<[^>]*>/g, '');
            if (condensedParts.length > 0 && !finalOutputString.endsWith('|')) outputHtml += '|';
            else if (!baseHeader && condensedParts.length > 0 && !finalOutputString.endsWith('|')) outputHtml += '|';
             outputHtml = outputHtml.replace(/\s{2,}/g, ' ').replace(/ <span/g, '<span').replace(/span> /g, 'span>');
            lastGeneratedOutput = outputHtml.replace(/<[^>]*>/g, '');

            // Update output display
            if (dom.outCode && document.activeElement !== dom.outCode) {
                 dom.outCode.innerHTML = outputHtml;
                 if (isManualEditMode) {
                     isManualEditMode = false;
                     if(dom.outCode) dom.outCode.classList.remove('manual-edit');
                     if(dom.outWrapper) {
                        dom.outWrapper.classList.remove('manual-edit');
                        const indicator = dom.outWrapper.querySelector('.manual-edit-indicator');
                        if (indicator) indicator.style.display = 'none';
                     }
                 }
            }
            if (dom.duplicateInfoOutput) dom.duplicateInfoOutput.textContent = ''; // Clear duplicate info
            // Ensure message area is hidden unless an error occurs later
            if (dom.messageArea && dom.messageArea.style.display !== 'none' && !dom.messageArea.classList.contains('error')) {
                 dom.messageArea.style.display = 'none';
            }
        } catch (err) {
            showMessage(`Error generating output: <code>${err.message}</code>. Check builder setup and data.`, 'error');
            console.error("Output Generation Error:", err);
            if(dom.outCode) dom.outCode.textContent = '[Error generating output]';
            lastGeneratedOutput = '';
            if(dom.duplicateInfoOutput) dom.duplicateInfoOutput.textContent = '';
        }
    }

    // --- Dynamic UI Population (Decoder/Editor) ---
    function createSelector(partConfig, idPrefix = 'part-') { /* ... function unchanged ... */
        const container = document.createElement('div');
        container.className = 'mb-3';

        const label = document.createElement('label');
        label.htmlFor = idPrefix + partConfig.value;
        label.textContent = partConfig.text + ':';
        container.appendChild(label);

        if (partConfig.type === 'number') {
            const input = document.createElement('input');
            input.type = 'number';
            input.id = idPrefix + partConfig.value;
            input.min = partConfig.min || 0;
            if (partConfig.max) input.max = partConfig.max;
            input.value = partConfig.defaultValue || '';
            input.className = 'w-full md:w-auto';
            input.addEventListener('change', rebuildOutput);
            input.addEventListener('input', rebuildOutput); // More responsive
            container.appendChild(input);
        } else { // Default to select dropdown
            const select = document.createElement('select');
            select.id = idPrefix + partConfig.value;
            select.className = 'w-full';

             // Add options
             (partConfig.options || [partConfig]).forEach(option => {
                 const opt = document.createElement('option');
                 opt.value = option.value;
                 opt.textContent = option.text;
                 select.appendChild(opt);
             });

            select.addEventListener('change', rebuildOutput);
            container.appendChild(select);
        }
        return container;
     }
    function populatePartSelectors() { /* ... function unchanged ... */
        if (!dom.partSelectorsContainer) return;
        dom.partSelectorsContainer.innerHTML = ''; // Clear previous

         // Group parts logically (Example: Item Info, Core, Elements, Specific Parts...)
         const sections = {
             'Item Info': ['itemInfo'],
             'Core': ['core', 'elements'],
             'Legendary Perks': ['legendaryPerks'],
             'Ordnance Perks': ['ordnancePerks'],
         };

         // Manually add Item Type options (example)
         const coreData = PARTS_DATA.core.find(p => p.value === 'itemType');
         if (coreData) {
            coreData.options = [
                {text: "Order / Assault Rifle", value: "15, 0"}, {text: "Jakobs / Shotgun", value: "9, 0"},
                {text: "Maliwan / Sniper", value: "25, 0"},
            ];
         }


         Object.entries(sections).forEach(([sectionTitle, partKeys]) => {
             const sectionContainer = document.createElement('div');
             sectionContainer.className = 'mb-4';

             const header = document.createElement('div');
             header.className = 'collapsible-header';
             header.innerHTML = `<span>${sectionTitle}</span><span class="collapsible-arrow">▶</span>`;
             sectionContainer.appendChild(header);

             const content = document.createElement('div');
             content.className = 'collapsible-content p-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4';

             partKeys.forEach(key => {
                 const partList = PARTS_DATA[key];
                 if (partList && partList.length > 0) {
                     const configs = Array.isArray(partList) ? partList : [partList];
                     configs.forEach(partConfig => {
                        if (!partConfig) return; // Skip if partConfig is null/undefined
                        // Check if it's a config object with options OR a type 'number'
                        if (partConfig.options || partConfig.type === 'number') {
                             content.appendChild(createSelector(partConfig));
                        } else if (configs.length > 1 && !partConfig.options && partConfig.type !== 'number') {
                            // If it's part of a list (like elements) but doesn't have its own options, group them
                            // Check if a dropdown for this key already exists
                            let existingSelect = content.querySelector(`#part-${key}`);
                            if (!existingSelect) {
                                // Create a single dropdown for the group
                                const combinedConfig = { text: sectionTitle, value: key, options: configs.filter(Boolean) }; // Filter out nulls
                                content.appendChild(createSelector(combinedConfig));
                            }
                            // Options are added within createSelector for the combinedConfig
                        } else {
                            // Single item config (like itemInfo previously)
                             content.appendChild(createSelector(partConfig));
                        }

                     });
                 }
             });
             sectionContainer.appendChild(content);
             dom.partSelectorsContainer.appendChild(sectionContainer);
         });
         setupCollapsibleSections();
     }
     function setupCollapsibleSections() { /* ... function unchanged ... */
         document.querySelectorAll('.collapsible-header').forEach(header => {
             header.addEventListener('click', () => {
                 const content = header.nextElementSibling;
                 if (content) {
                    const isOpen = content.classList.contains('open');
                    content.classList.toggle('open', !isOpen);
                    header.classList.toggle('open', !isOpen);
                 }
             });
         });
      }


    // --- Generic Selector Logic ---
    function getDatasetFromPayload(key) { return PAYLOAD[key] || []; }
    function populateSelectorAvailableList() { /* ... function unchanged ... */
        const dataset = getDatasetFromPayload(currentSelectorDatasetKey);
        dom.selectorAvailableList.innerHTML = ''; // Clear existing options

        dataset.forEach((item, index) => {
            const option = document.createElement('option');
            option.value = item.code || item.value || index;
            option.textContent = item.name || item.text || `Item ${index + 1}`;
            option.dataset.itemData = JSON.stringify(item);
            dom.selectorAvailableList.appendChild(option);
        });
    }
    function updateSelectorSelectedList() { /* ... function unchanged ... */
        dom.selectorSelectedList.innerHTML = ''; // Clear existing
        selectorSelectedItems.forEach((item, index) => {
            const option = document.createElement('option');
            option.value = item.value;
            option.textContent = item.text;
            option.dataset.originalIndex = index;
            dom.selectorSelectedList.appendChild(option);
        });
        renderSelectorOutput(); // Update output whenever selection changes
    }
    function handleSelectorAdd() { /* ... function unchanged ... */
        Array.from(dom.selectorAvailableList.selectedOptions).forEach(option => {
            selectorSelectedItems.push({ value: option.value, text: option.textContent });
        });
        updateSelectorSelectedList();
     }
    function handleSelectorRemove() { /* ... function unchanged ... */
        const indicesToRemove = Array.from(dom.selectorSelectedList.selectedOptions)
            .map(option => parseInt(option.dataset.originalIndex, 10))
            .sort((a, b) => b - a);

        indicesToRemove.forEach(index => {
            if (index >= 0 && index < selectorSelectedItems.length) {
                selectorSelectedItems.splice(index, 1);
            }
        });
        updateSelectorSelectedList();
     }
     function renderSelectorOutput() { /* ... function unchanged ... */
         let outputString = "";
         const selectedValues = selectorSelectedItems.map(item => item.value);

         if (selectedValues.length === 0) {
             dom.selectorOutput.textContent = "[Select items to generate output]";
             return;
         }

         if (currentSelectorDatasetKey === 'enhancementStats') {
             const numericValues = selectedValues.map(v => typeof v === 'number' ? v : (v.match(/\d+/)?.[0])).filter(Boolean);
             if (numericValues.length > 0) outputString = `{247:[${numericValues.join(' ')}]}`;
         } else if (currentSelectorDatasetKey === 'legendaryPerks') {
              outputString = selectedValues.join(' ');
         } else {
             outputString = selectedValues.join(' ');
         }

         dom.selectorOutput.textContent = outputString || "[Output formatting not defined for this dataset]";
      }


    // --- Tab Switching Logic ---
    function setupTabs() { /* ... function unchanged ... */
        dom.tabLinks.forEach(link => {
            link.addEventListener('click', () => {
                const tabId = link.getAttribute('data-tab');
                dom.tabLinks.forEach(l => l.classList.remove('active'));
                link.classList.add('active');
                dom.tabContents.forEach(content => {
                    content.classList.toggle('active', content.id === tabId);
                });
            });
        });
    }

    // --- Duplicate Analysis Logic (NEW - Now correctly placed) ---
    function analyzeDuplicates(serialString) { /* ... function unchanged ... */
        const counts = { singular: {}, specific: {}, arrayValues: {} };
        const parts = (serialString.split('||')[1] || '').trim().split(/\s+/).filter(p => p.length > 0);
        parts.forEach(part => {
            const singularMatch = part.match(/^\{(\d+)\}$/);
            const specificMatch = part.match(/^\{(\d+:\d+)\}$/);
            const arrayMatch = part.match(/^\{(\d+):\[([^\]]+)\]\}$/);
            if (singularMatch) { counts.singular[singularMatch[1]] = (counts.singular[singularMatch[1]] || 0) + 1; }
            else if (specificMatch) { counts.specific[specificMatch[1]] = (counts.specific[specificMatch[1]] || 0) + 1; }
            else if (arrayMatch) {
                const id = arrayMatch[1];
                const values = arrayMatch[2].trim().split(/\s+/).filter(v => v);
                values.forEach(val => { counts.arrayValues[`${id}-${val}`] = (counts.arrayValues[`${id}-${val}`] || 0) + 1; });
            }
        });
        const duplicates = {
            singular: Object.entries(counts.singular).filter(([, count]) => count > 1).map(([id]) => id),
            specific: Object.entries(counts.specific).filter(([, count]) => count > 1).map(([key]) => key),
            arrayValues: Object.entries(counts.arrayValues).filter(([, count]) => count > 1).map(([key]) => key)
        };
        return { counts, duplicates };
    }
    function formatDuplicateAnalysis(analysis) { /* ... function unchanged ... */
        const { counts, duplicates } = analysis; let output = "";
        const singularDups = duplicates.singular.map(id => `{${id}} (${counts.singular[id]} times)`);
        if (singularDups.length > 0) output += `Singular blocks: ${singularDups.join(', ')}. `;
        const specificDups = duplicates.specific.map(key => `{${key}} (${counts.specific[key]} times)`);
        if (specificDups.length > 0) output += `Specific blocks: ${specificDups.join(', ')}. `;
        const arrayDups = duplicates.arrayValues.map(key => { const [id, val] = key.split('-'); return `${val} (${counts.arrayValues[key]} times in {${id}:[...]})`; });
        if (arrayDups.length > 0) output += `Array values: ${arrayDups.join(', ')}.`;
        return output.trim() || "No duplicates found.";
    }
    function analyzeAndDisplayDuplicates() { /* ... function unchanged ... */
        const currentSerial = dom.outCode?.textContent || '';
        if (!currentSerial || currentSerial.startsWith('[')) {
            if(dom.duplicateInfoOutput) dom.duplicateInfoOutput.textContent = 'No output serial to analyze.';
            return;
        }
        const analysis = analyzeDuplicates(currentSerial);
        if(dom.duplicateInfoOutput) dom.duplicateInfoOutput.textContent = formatDuplicateAnalysis(analysis);
    }

    // --- Initialization ---
    async function initializeApp() { // Changed to async for await fetch
        currentBaseInputString = '';
        try {
            console.log("Initializing App...");

            // Fetch PAYLOAD data first
            const response = await fetch('bl4_parts_data.json'); // Assuming this file exists alongside the HTML
            if (!response.ok) throw new Error(`HTTP error ${response.status} fetching bl4_parts_data.json`);
            try { PAYLOAD = await response.json(); }
            catch (jsonError) { throw new Error(`Failed to parse bl4_parts_data.json: ${jsonError.message}.`); }
            // Basic validation of PAYLOAD structure (optional but recommended)
            const requiredKeys = ['legendaryPerks', 'enhancementStats']; // Add others as needed
            const missingKeys = requiredKeys.filter(key => !PAYLOAD[key] || !Array.isArray(PAYLOAD[key]));
            if (missingKeys.length > 0) console.warn(`Payload validation warning: Key(s) ${missingKeys.join(', ')} missing/invalid.`);

            // Now build lookups and part data using the loaded PAYLOAD
            buildLookupMapsAndPartData();

            // Populate UI elements that depend on PAYLOAD/PARTS_DATA
            populatePartSelectors(); // Depends on PARTS_DATA which depends on PAYLOAD
            setupTabs();

             // Setup Generic Selector
             if (dom.datasetSelector) {
                 // Clear any placeholder options first
                 // dom.datasetSelector.innerHTML = '';
                 Object.keys(PAYLOAD).forEach(key => {
                     if (Array.isArray(PAYLOAD[key])) {
                         const option = document.createElement('option');
                         option.value = key;
                         option.textContent = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                         if (!dom.datasetSelector.querySelector(`option[value="${key}"]`)) {
                              dom.datasetSelector.appendChild(option);
                         }
                     }
                 });
                 dom.datasetSelector.value = currentSelectorDatasetKey;
             }

             if (dom.selectorAvailableList) populateSelectorAvailableList();
             if (dom.selectorSelectedList) updateSelectorSelectedList();

             // Event Listeners (ensure DOM elements exist before adding listeners)
             if (dom.datasetSelector) dom.datasetSelector.addEventListener('change', (e) => {
                 currentSelectorDatasetKey = e.target.value; selectorSelectedItems = [];
                 populateSelectorAvailableList(); updateSelectorSelectedList();
             });
             if (dom.selectorAddBtn) dom.selectorAddBtn.addEventListener('click', handleSelectorAdd);
             if (dom.selectorRemoveBtn) dom.selectorRemoveBtn.addEventListener('click', handleSelectorRemove);
             if (dom.copySelectorOutputBtn) dom.copySelectorOutputBtn.addEventListener('click', async () => { /* ... copy logic ... */ });

             if (dom.serialOutputCode) dom.serialOutputCode.addEventListener('input', () => { rebuildOutput(); debouncedApiCall(); });
             if (dom.rebuildAndCallApiBtn) dom.rebuildAndCallApiBtn.addEventListener('click', () => { rebuildOutput(); callReserialize(); });
             if (dom.copyFull) dom.copyFull.addEventListener('click', async () => { /* ... copy logic ... */ });
             if (dom.copySerial) dom.copySerial.addEventListener('click', async () => { /* ... copy logic ... */ });

             if (dom.analyzeDuplicatesBtn) dom.analyzeDuplicatesBtn.addEventListener('click', analyzeAndDisplayDuplicates); // Attach listener

             // Manual Edit Handling
             if (dom.outCode) dom.outCode.addEventListener('input', () => {
                isManualEditMode = true;
                if(dom.outCode) dom.outCode.classList.add('manual-edit');
                if(dom.outWrapper) {
                    dom.outWrapper.classList.add('manual-edit');
                    const indicator = dom.outWrapper.querySelector('.manual-edit-indicator');
                    if(indicator) indicator.style.display = 'inline';
                }
                clearTimeout(apiDebounceTimeout); // Use correct timeout var
             });

             // Undo Edit
            if (dom.undoEditBtn) dom.undoEditBtn.addEventListener('click', () => {
                if (lastGeneratedOutput) {
                    isManualEditMode = false;
                    currentBaseInputString = lastGeneratedOutput; // Restore plain text
                    rebuildOutput(); // Rebuild with highlighting
                    if (dom.outCode) dom.outCode.classList.remove('manual-edit');
                    if(dom.outWrapper) {
                         dom.outWrapper.classList.remove('manual-edit');
                         const indicator = dom.outWrapper.querySelector('.manual-edit-indicator');
                         if(indicator) indicator.style.display = 'none';
                    }
                    debouncedApiCall(); // Resume API calls
                    showCopyStatus(dom.copyFullStatus, 'Edit Undone');
                    if (dom.duplicateInfoOutput) dom.duplicateInfoOutput.textContent = '';
                } else { showCopyStatus(dom.copyFullStatus, 'No history!'); }
            });

            if (dom.reserializeManualBtn) dom.reserializeManualBtn.addEventListener('click', callReserialize);


             rebuildOutput(); // Initial build
             setTimeout(callReserialize, 150); // Initial API call

        } catch (error) {
            console.error("Initialization failed:", error);
            // Ensure showMessage is defined before calling it in catch
            showMessage(`Initialization failed: ${error.message}`, 'error', 10000);
            document.querySelectorAll('input, select, button, [contenteditable]').forEach(el => {
                if(el) el.disabled = true; // Add null check for safety
            });
             if (dom.outCode) dom.outCode.contentEditable = false;
        }
    }

    // --- Run Initialization ---
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp(); // Already loaded
    }

})();
</script>
</body>
</html>

