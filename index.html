<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport"/>
    <title>BL4 Weapon Part Editor (Hosted)</title>
    <style>
        /* Base styles adapted from Enhancement_Editor.html */
        :root {
            --bg:#0b0f14; --card:#0e1520; --ink:#e6f0ff; --muted:#a6b4c8; --line:#1f2a3a;
            --accent-orange: #e59400; --danger-red: #e74c3c; --success-green: #28a745; --edit-yellow: #ffc107;
            /* NEW Duplicate Highlight Colors */
            --dup-blue: #6495ED; /* Cornflower blue */
            --dup-orange: #FFA500; /* Orange */
            --dup-yellow: #FFD700; /* Gold */
        }
        * { box-sizing: border-box; }
        body { font-family: 'Inter', system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--bg); color: var(--ink); padding: 0; /* Remove body padding */ font-size: 16px; line-height: 1.5; margin: 0; }

        /* --- NEW TAB NAVIGATION STYLES --- */
        .tab-nav {
            background-color: var(--card); /* Match card background */
            border-bottom: 1px solid var(--line);
            padding: 0 18px; /* Horizontal padding like body had */
            margin-bottom: 18px; /* Space below nav */
            display: flex;
            gap: 10px;
        }
        .tab-link {
            display: inline-block;
            padding: 12px 16px;
            color: var(--muted);
            text-decoration: none;
            border-bottom: 3px solid transparent; /* Placeholder for active state */
            transition: color 0.2s ease, border-color 0.2s ease;
            font-weight: 500;
            font-size: 15px;
        }
        .tab-link:hover {
            color: var(--ink);
        }
        .tab-link.active {
            color: var(--accent-orange);
            border-bottom-color: var(--accent-orange);
        }
        /* --- END NEW TAB STYLES --- */

        .container { max-width: 1200px; margin: 0 auto; padding: 0 18px 18px 18px; /* Padding moved here */ } /* Added container padding */
        h2 { margin: 0 0 14px; border-bottom: 1px solid var(--line); padding-bottom: 8px; font-weight: 700; }
        .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
        .card { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 14px 16px; display: flex; flex-direction: column; margin-bottom: 14px; }
        label { color: var(--muted); font-size: 12px; display: block; margin-bottom: 6px; font-weight: 400; }
        select, input, textarea, button { background: #0f1720; color: var(--ink); border: 1px solid var(--line); border-radius: 10px; padding: 10px 12px; font-size: 16px; font-family: inherit; }
        textarea { font-family: monospace; resize: vertical; } /* Added monospace & resize */
        input::placeholder { color: var(--muted); opacity: 0.7; }
        select[multiple] { padding: 4px; /* Adjust padding for multi-select */ }
        select:focus, input:focus, textarea:focus, button:focus { outline: 2px solid var(--accent-orange); outline-offset: 1px; border-color: var(--accent-orange); }
        code { background:#0c121b; border: 1px solid var(--line); padding: 4px 8px; display: inline-block; border-radius: 6px; font-size: 0.9em; font-family: monospace; }
        button { cursor: pointer; background-color: #2c2c4d; transition: background-color 0.2s ease; }
        button:hover { background-color: #4b4b7d; }
        button:disabled { background-color: #2c2c4d; opacity: 0.5; cursor: not-allowed; }
        button.small { padding: 6px 10px; border-radius: 8px; font-size: 14px; min-height: 38px; min-width: 38px; }
        .wrap { white-space: normal; word-break: break-word; }

        /* Generic Builder Style */
        .builderSection .row.titleRow { justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: nowrap; }
        .builderSection .row.titleRow > div:first-child { font-weight: 700; color: var(--muted); font-size: 14px; white-space: nowrap; }
        .builderSection .row.filterRow { justify-content: flex-end; gap: 8px; flex-grow: 1; }
        .builderSection .row.filterRow input[type="text"] { flex-grow: 1; min-width: 150px; }
        /* .builderSection .row.filterRow input.delimiter { width: 100px; flex-grow: 0; display: none; } */
        .builderSection .row.selects { margin-top: 8px; display: flex; gap: 10px; align-items: stretch; }
        .builderSection select { flex: 1; min-height: 220px; width: 100%; border-radius: 8px;}
        .builderSection .buttons { display: flex; flex-direction: column; gap: 8px; justify-content: center; width: 56px; align-items: center; }
        .builderSection .tip { margin-top: 10px; font-size: 12px; color: var(--muted); }

        /* Collapsible Section Styles */
        .collapsible .collapsible-content {
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.3s ease-out;
            margin-top: 0; /* Ensure no margin when collapsed */
        }
        .collapsible .collapsible-content.expanded {
            max-height: 1000px; /* Adjust if needed for very long content */
            transition: max-height 0.5s ease-in;
            margin-top: 10px; /* Add space when expanded */
        }
        .toggle-btn {
            background: none; border: none; font-size: 1.2em; cursor: pointer;
            padding: 0 8px; margin-left: 5px; color: var(--success-green); opacity: 0.7;
            transition: opacity 0.2s ease, color 0.2s ease;
        }
        .toggle-btn:hover { opacity: 1; }
        .toggle-btn.expanded-btn { color: var(--danger-red); }
        .titleRow .toggle-btn { margin-left: auto; /* Push button to the right in builder title rows */ }
        /* Ensure headers stay aligned with button */
        .card > h2, .builderSection .row.titleRow > div:first-child { display: inline-block; /* Keep header text inline */ }

        /* Output Box Styling */
        .outCard code {
            display: block; overflow: auto; width: 100%; white-space: pre-wrap; word-break: break-all;
            max-height: 120px; /* Consistent max height */
            min-height: 50px;
            background: #0c121b; padding: 10px; border-radius: 8px; border: 2px solid var(--line); transition: border-color 0.3s ease;
            font-family: monospace; /* Ensure monospace */
        }
        .outCard code[contenteditable="plaintext-only"]:focus { /* Changed selector */
             outline: none; border-color: var(--edit-yellow);
        }
        .outCard code.manual-edit { border-color: var(--edit-yellow); }

        #apiCard code#serial_b85 { /* Specific ID for API result */
             max-height: 100px;
             overflow-y: auto; /* Enable vertical scroll */
             display: block; /* Ensure it behaves as a block */
             white-space: pre-wrap; /* Allow wrapping */
             word-break: break-all; /* Break long words/serials */
        }
        .sticky { position: sticky; top: 0; /* Adjust to 0 since body padding removed */ z-index: 20; background: var(--bg); /* Add bg to prevent content showing through */} /* Made sticky start from top */

         /* Base Serial Input Box Styling */
        #baseSerial {
            width: 100%; min-height: 80px; margin-top: 6px; padding: 8px 10px;
            background: #141c27; /* Slightly lighter background */
            color: var(--ink); border: 1px solid var(--line); border-radius: 8px;
            font-family: monospace; font-size: 0.9em;
        }

         /* Universal Message Area Styling (Fallback for Toast) */
        #message-area {
            padding: 10px 18px; /* Match container padding */
            margin-bottom: 14px;
            border-radius: 8px;
            font-size: 14px;
            display: none; /* Hidden by default */
            border: 1px solid transparent;
        }
        #message-area.visible { display: block; }
        #message-area.error { background-color: rgba(231, 76, 60, 0.2); border-color: var(--danger-red); color: var(--danger-red); }
        #message-area.success { background-color: rgba(40, 167, 69, 0.2); border-color: var(--success-green); color: var(--success-green); }

        .copy-status { font-size: 12px; color: var(--muted); margin-left: 5px; opacity: 0; transition: opacity 0.3s ease; }
        .copy-status.visible { opacity: 1; }

        .manual-edit-indicator { display: none; font-size: 11px; color: var(--edit-yellow); margin-left: 8px; }
        .outCard.manual-edit .manual-edit-indicator { display: inline; }

        /* --- Style for Added Parts --- */
        .added-part {
            color: var(--success-green);
            font-weight: 500; /* Slightly bolder */
        }
        /* --- Styles for Duplicate Parts --- */
        .dup-block-simple { color: var(--dup-blue); font-weight: bold; }
        .dup-block-value { color: var(--dup-orange); font-weight: bold; }
        .dup-array-value { color: var(--dup-yellow); font-weight: bold; }

        /* --- Duplicate Info Styles --- */
         #duplicateInfo {
             font-size: 12px;
             color: var(--muted);
             margin-top: 10px;
             padding-top: 10px;
             border-top: 1px solid var(--line);
             max-height: 100px; /* Limit height */
             overflow-y: auto; /* Add scroll if needed */
             /* Horizontal layout for entries */
             display: flex;
             flex-wrap: wrap;
             gap: 15px; /* Space between entries */
         }
         #duplicateInfo h4 { /* Style for subheadings */
             font-size: 13px;
             color: var(--ink);
             margin: 0 0 4px 0; /* Adjusted margin */
             font-weight: 600;
             width: 100%; /* Make title take full width */
         }
         #duplicateInfo .duplicate-category {
             margin-bottom: 5px; /* Space below category title */
             width: 100%; /* Ensure category title takes full width */
         }
         #duplicateInfo .duplicate-entry {
             font-family: monospace;
             margin-right: 15px; /* Spacing between horizontal items */
             white-space: nowrap; /* Prevent wrapping within an entry */
         }
         #duplicateInfo .dup-block-simple { color: var(--dup-blue); }
         #duplicateInfo .dup-block-value { color: var(--dup-orange); }
         #duplicateInfo .dup-array-value { color: var(--dup-yellow); }


        /* Message Toast Styles */
        .message-toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); display: none; align-items: center; gap: 10px; z-index: 10000; opacity: 0; transition: opacity 0.3s ease, bottom 0.3s ease; font-size: 15px; }
        .message-toast.show { display: flex; opacity: 1; bottom: 30px; }
        .message-toast.success { background-color: rgba(40, 167, 69, 0.9); border: 1px solid var(--success-green); }
        .message-toast.error { background-color: rgba(231, 76, 60, 0.9); border: 1px solid var(--danger-red); }
        .message-toast.info { background-color: rgba(23, 162, 184, 0.9); border: 1px solid #17a2b8; }
        .toast-icon { font-size: 1.2em; }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .tab-nav { padding: 0 10px; margin-bottom: 10px; } /* Adjust padding */
            .tab-link { padding: 10px 8px; font-size: 14px; } /* Smaller tabs */
            .container { padding: 0 10px 10px 10px; } /* Adjust container padding */
            .outCard code { max-height: 100px; } /* Slightly smaller max height on mobile */
            .outCard .row { flex-wrap: wrap; }
            .outCard .row button.small { min-height: 30px; } /* Smaller button size */
            #analyzeDuplicatesBtn { padding: 4px 8px !important; font-size: 12px !important; } /* Smaller analyze button */
            .builderSection .row.selects { flex-direction: column; } /* Stack selects/buttons vertically */
            .builderSection .buttons { flex-direction: row; width: auto; margin: 8px 0; } /* Horizontal buttons */
            .builderSection select { min-height: 150px; } /* Reduce select height */
            .collapsible .collapsible-content.expanded { max-height: 600px; /* Adjust max height for mobile */ }
            #duplicateInfo { flex-direction: column; gap: 5px; max-height: 80px; } /* Stack duplicates vertically on mobile */
            #duplicateInfo .duplicate-entry { margin-right: 0; }
        }
    </style>
</head>
<body class="loading"> <!-- Start with loading class -->

    <!-- NEW TAB NAVIGATION BAR -->
    <nav class="tab-nav">
        <a href="Deseralizer Comparator.html" class="tab-link">Comparator & Editor</a>
        <a href="Deseralizer Comparator.html#deserializer" class="tab-link">Deserializer</a>
        <a href="bl4_decoder.html" class="tab-link active">Workstation</a> <!-- Use filename or # -->
    </nav>
    <!-- END TAB NAVIGATION BAR -->

<div class="container">
    <div id="message-area"></div> <!-- Universal Message/Error display area -->
    <h2>BL4 Weapon Part Editor (Workstation)</h2> <!-- Added subtitle -->

    <!-- Input Serial Section - UPDATED -->
    <div class="card collapsible" id="inputCard"> <!-- Made collapsible -->
         <h2>Input Base Serial String</h2> <!-- Added header -->
         <div class="collapsible-content"> <!-- Content wrapper -->
            <label for="baseSerial">Paste Serial (Game format @U...) or Deserialized Code Block:</label>
            <textarea id="baseSerial" rows="3" placeholder="Paste @U... serial (click Deserialize first) OR deserialized format like: 9, 0, 1, 50| 2, 1626|| {80} {2}|"></textarea>
             <p style="margin-top: 10px; opacity: 0.8; font-size: 0.9em;">
                 <strong>Step 1:</strong> If you have a <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">@U...</code> serial, click <strong>"Deserialize Serial Code"</strong> first.<br>
                 <strong>Step 2:</strong> Then click <strong>"Apply Code Block"</strong> to use the content below as the base for adding parts.
             </p>
            <div class="button-group" style="margin-top: 10px;">
                <button class="btn btn-primary" id="applyInputBtn">Apply Code Block</button>
                <button class="btn btn-info" id="deserializeBtn">Deserialize Serial Code</button>
            </div>
         </div>
    </div>

    <!-- Output + API (Sticky) -->
    <div class="card outCard sticky">
        <div class="row" style="justify-content: space-between; align-items: center;">
            <div style="color:var(--muted)">Output Serial String <span class="manual-edit-indicator">(Manual Edit Mode)</span></div>
            <div class="row">
                 <button class="small" id="reserializeManual" title="Reserialize Manual Edit">üîÑ API</button>
                 <button class="small" id="undoEdit" title="Undo Manual Edit & Rebuild">‚Ü©Ô∏è Undo</button>
                 <button class="small" id="copyFull" title="Copy Output String">üìã</button>
                 <span id="copyFullStatus" class="copy-status"></span>
            </div>
        </div>
        <div id="out" style="margin-top:6px"><code contenteditable="plaintext-only"><!-- Output code will appear here --></code></div>
        <!-- Analyze Button & Info Area -->
        <button class="small" id="analyzeDuplicatesBtn" title="Analyze & Highlight Duplicates" style="margin-top: 10px; width: fit-content;">üìä Analyze</button>
        <div id="duplicateInfo"></div> <!-- Placeholder for duplicate info -->
    </div>

    <div class="card" id="apiCard" style="margin-bottom:14px">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
            <div>
                <div style="color:var(--muted)">Validated Serial (API Result)</div>
                <div id="serialWrap" style="margin-top:6px"><code id="serial_b85"><!-- API Serial B85 --></code></div>
                <div id="addDataWrap" style="margin-top:6px;color:var(--muted); font-size: 12px;">
                    <span style="opacity:.8">Details:</span> <code id="additionalData" style="font-size: 12px;"><!-- API Additional Data --></code>
                </div>
            </div>
            <div class="row" style="gap:8px">
                <button class="small" id="copySerial" title="Copy API Serial" disabled>üìã</button>
                <span id="copyApiStatus" class="copy-status"></span>
            </div>
        </div>
    </div>

    <div id="mainContent">
        <!-- Base Item Info (Simplified Placeholders) -->
        <div class="card collapsible"> <!-- Made collapsible -->
             <h2>Base Item Properties</h2> <!-- Added header -->
             <div class="collapsible-content"> <!-- Content wrapper -->
                 <div class="row">
                    <div style="flex: 1;">
                        <label>Base Item Type (Placeholder)</label>
                        <select id="itemTypeSel">
                            <option value="gun">Generic Gun</option>
                            <option value="shield">Shield</option>
                            <option value="grenade">Grenade Mod</option>
                            <option value="classmod">Class Mod</option>
                            <option value="enhancement">Enhancement</option>
                        </select>
                    </div>
                     <div style="flex: 1;">
                        <label>Rarity (Placeholder)</label>
                        <select id="raritySel">
                            <option value="common">Common</option>
                            <option value="uncommon">Uncommon</option>
                            <option value="rare">Rare</option>
                            <option value="epic">Epic</option>
                            <option value="legendary">Legendary</option>
                        </select>
                    </div>
                 </div>
             </div>
        </div>

        <!-- Builder Sections (Moved Legendary above Alt Fire) -->
        <div class="card builderSection collapsible" data-key="legendaryPerks" data-name-field="name" data-code-field="code" data-id-prefix="LegPerk"> <!-- Made collapsible -->
             <div class="row titleRow">
                 <div>Legendary Perk Part Variations</div>
                 <div class="row filterRow">
                    <input id="filterLegPerk" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearLegPerk" title="Clear Selected">‚ùå</button>
                </div>
            </div>
             <div class="collapsible-content"> <!-- Content wrapper -->
                <div class="row selects">
                    <select id="availLegPerk" multiple size="8" aria-label="Available Legendary Perks"></select>
                    <div class="buttons">
                        <button id="addLegPerk" title="Add Selected">¬ª</button>
                        <button id="remLegPerk" title="Remove Selected">¬´</button>
                    </div>
                    <select id="selLegPerk" multiple size="8" aria-label="Selected Legendary Perks"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
            </div>
        </div>

        <div class="card builderSection collapsible" data-key="altFireModes" data-name-field="name" data-code-field="code" data-id-prefix="AltFire"> <!-- Made collapsible -->
            <div class="row titleRow">
                <div>Alt Fire Mode Variations</div>
                <div class="row filterRow">
                    <input id="filterAltFire" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearAltFire" title="Clear Selected">‚ùå</button>
                </div>
            </div>
             <div class="collapsible-content"> <!-- Content wrapper -->
                <div class="row selects">
                    <select id="availAltFire" multiple size="8" aria-label="Available Alt Fire Modes"></select>
                    <div class="buttons">
                        <button id="addAltFire" title="Add Selected">¬ª</button>
                        <button id="remAltFire" title="Remove Selected">¬´</button>
                    </div>
                    <select id="selAltFire" multiple size="8" aria-label="Selected Alt Fire Modes"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
            </div>
        </div>

        <div class="card builderSection collapsible" data-key="magazineModes" data-name-field="name" data-code-field="code" data-id-prefix="MagMode"> <!-- Made collapsible -->
             <div class="row titleRow">
                <div>Magazine / Ammo Mode Variations</div>
                 <div class="row filterRow">
                    <input id="filterMagMode" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearMagMode" title="Clear Selected">‚ùå</button>
                </div>
            </div>
             <div class="collapsible-content"> <!-- Content wrapper -->
                <div class="row selects">
                    <select id="availMagMode" multiple size="8" aria-label="Available Magazine/Ammo Modes"></select>
                    <div class="buttons">
                        <button id="addMagMode" title="Add Selected">¬ª</button>
                        <button id="remMagMode" title="Remove Selected">¬´</button>
                    </div>
                    <select id="selMagMode" multiple size="8" aria-label="Selected Magazine/Ammo Modes"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
            </div>
        </div>

        <div class="card builderSection collapsible" data-key="ordnancePerks" data-name-field="name" data-code-field="code" data-id-prefix="OrdPerk"> <!-- Made collapsible -->
             <div class="row titleRow">
                <div>Ordnance Legendary Perks (Heavy/Grenade)</div>
                 <div class="row filterRow">
                    <input id="filterOrdPerk" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearOrdPerk" title="Clear Selected">‚ùå</button>
                </div>
            </div>
             <div class="collapsible-content"> <!-- Content wrapper -->
                <div class="row selects">
                    <select id="availOrdPerk" multiple size="8" aria-label="Available Ordnance Perks"></select>
                    <div class="buttons">
                        <button id="addOrdPerk" title="Add Selected">¬ª</button>
                        <button id="remOrdPerk" title="Remove Selected">¬´</button>
                    </div>
                    <select id="selOrdPerk" multiple size="8" aria-label="Selected Ordnance Perks"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
            </div>
        </div>

    </div> <!-- End mainContent -->
</div> <!-- End container -->

<!-- Message Toast -->
<div id="messageToast" class="message-toast">
    <span id="toastIcon" class="toast-icon">‚úì</span>
    <span id="toastText">Success!</span>
</div>

<script>
    // Global variables
    let PAYLOAD = {};
    const builders = {};
    let rndSeed = Math.floor(1000 + Math.random() * 9000);
    let apiCallTimer;
    let rebuildTimer;
    let lastGeneratedOutput = '';
    let isManualEditMode = false;
    let currentBaseInputString = ''; // Store the validated base string

    // --- DOM Elements Cache ---
    const dom = {
        body: document.body,
        messageArea: document.getElementById('message-area'), // Fallback
        toast: document.getElementById('messageToast'),
        toastIcon: document.getElementById('toastIcon'),
        toastText: document.getElementById('toastText'),
        itemTypeSel: document.getElementById('itemTypeSel'),
        raritySel: document.getElementById('raritySel'),
        outWrapper: document.getElementById('out'),
        outCode: document.querySelector('#out code'),
        baseSerial: document.getElementById('baseSerial'), // Textarea for input
        applyInputBtn: document.getElementById('applyInputBtn'), // Apply button
        deserializeBtn: document.getElementById('deserializeBtn'), // Deserialize button
        serial_b85: document.getElementById('serial_b85'),
        additionalData: document.getElementById('additionalData'),
        copyFull: document.getElementById('copyFull'),
        copySerial: document.getElementById('copySerial'),
        analyzeDuplicatesBtn: document.getElementById('analyzeDuplicatesBtn'), // NEW Analyze button
        duplicateInfo: document.getElementById('duplicateInfo'), // NEW Info area
        copyFullStatus: document.getElementById('copyFullStatus'),
        copyApiStatus: document.getElementById('copyApiStatus'),
        undoEditBtn: document.getElementById('undoEdit'),
        reserializeManualBtn: document.getElementById('reserializeManual'),
    };

    // --- Utility Functions ---
    function showMessage(text, type = 'info') { // Default type: info
        if (dom.toast && dom.toastIcon && dom.toastText) {
            dom.toastIcon.textContent = type === 'success' ? '‚úÖ' : (type === 'error' ? '‚ùå' : '‚ÑπÔ∏è');
            dom.toastText.innerHTML = text; // Use innerHTML to allow basic tags like <code>
            dom.toast.className = `message-toast ${type} show`;

            clearTimeout(dom.toast.timer);
            dom.toast.timer = setTimeout(() => {
                dom.toast.classList.remove('show');
            }, type === 'error' ? 5000 : 3000); // Longer timeout for errors
        } else { // Fallback to message area
            console.warn("Toast elements not found, using fallback message area.");
            dom.messageArea.innerHTML = text;
            dom.messageArea.className = `message-area visible ${type}`; // Use type as class
            dom.messageArea.style.display = 'block';

            if (type !== 'error') {
                clearTimeout(dom.messageArea.timer);
                dom.messageArea.timer = setTimeout(() => {
                    dom.messageArea.style.display = 'none';
                    dom.messageArea.classList.remove('visible');
                }, 3000);
            }
        }
    }

    function showCopyStatus(statusElement, message) { // Keep this for inline copy feedback? Or switch to toast? Let's keep for now.
        if (!statusElement) return;
        statusElement.textContent = message;
        statusElement.classList.add('visible');
        clearTimeout(statusElement.timer);
        statusElement.timer = setTimeout(() => {
            statusElement.classList.remove('visible');
        }, 1500);
    }

    // --- Generic Builder UI Logic (unchanged) ---
    function createBuilder(key, nameField, codeField, idPrefix) {
        const dataList = PAYLOAD[key] || [];
        const filterInput = document.getElementById(`filter${idPrefix}`);
        const availList = document.getElementById(`avail${idPrefix}`);
        const selList = document.getElementById(`sel${idPrefix}`);
        const addBtn = document.getElementById(`add${idPrefix}`);
        const remBtn = document.getElementById(`rem${idPrefix}`);
        const clearBtn = document.getElementById(`clear${idPrefix}`);

        if (!filterInput || !availList || !selList || !addBtn || !remBtn || !clearBtn) {
            const missing = ['filter', 'avail', 'sel', 'add', 'rem', 'clear']
                            .filter(suffix => !document.getElementById(`${suffix}${idPrefix}`))
                            .map(suffix => `<code>${suffix}${idPrefix}</code>`)
                            .join(', ');
            throw new Error(`Initialization Error: Missing DOM elements for builder prefix <code>${idPrefix}</code>: ${missing}. Check HTML IDs.`);
        }

        let selectedItems = [];
        const codeToNameMap = {};

        if (!Array.isArray(dataList)) {
            throw new Error(`Data Validation Error: Expected an array for key <code>${key}</code> in JSON data, but got <code>${typeof dataList}</code>.`);
        }

        dataList.forEach(item => {
            const code = item[codeField];
            if (code === undefined || code === null) return;
            const name = item[nameField] || 'Unnamed Item';
            const variant = item.variant ? ` "${item.variant}"` : '';
            const group = item.group ? ` (${item.group})` : '';
            codeToNameMap[code] = `${name}${variant}${group}`;
        });

        function populateAvailable() {
            const fragment = document.createDocumentFragment();
            const query = (filterInput.value || '').toLowerCase();
            availList.innerHTML = '';
            (dataList || [])
                .filter(item => {
                    const code = item[codeField];
                    if (code === undefined || code === null) return false;
                    const name = codeToNameMap[code] || '';
                    const searchText = `${name} {${code}}`.toLowerCase(); // Include code in search
                    return !query || searchText.includes(query);
                })
                .sort((a, b) => { // Sort alphabetically by display name
                     const nameA = codeToNameMap[a[codeField]] || '';
                     const nameB = codeToNameMap[b[codeField]] || '';
                     return nameA.localeCompare(nameB);
                 })
                .forEach(item => {
                    const code = item[codeField];
                    const displayName = codeToNameMap[code];
                    const o = document.createElement('option');
                    o.value = code;
                    o.textContent = `${displayName} {${code}}`; // Display code in list
                    fragment.appendChild(o);
                });
            availList.appendChild(fragment);
        }

        function renderSelected() {
            const scrollState = { top: selList.scrollTop, left: selList.scrollLeft };
            const selectedValues = new Set(Array.from(selList.selectedOptions).map(opt => opt.value)); // Preserve selection
            selList.innerHTML = '';
            selectedItems.forEach((code, index) => {
                const name = codeToNameMap[code] || 'Unknown Code';
                const o = document.createElement('option');
                o.value = code;
                o.textContent = `${name} {${code}}`; // Display code in list
                o.dataset.index = index; // Store original index for removal
                if (selectedValues.has(code)) { // Re-select if it was selected
                    o.selected = true;
                }
                selList.appendChild(o);
            });
             selList.scrollTop = scrollState.top;
             selList.scrollLeft = scrollState.left;
             if (!isManualEditMode) {
                 triggerDebouncedRebuild();
             }
        }

        function addSelected() {
            Array.from(availList.selectedOptions).forEach(opt => selectedItems.push(opt.value));
            renderSelected();
        }

        function removeSelected() {
            // Get indices of selected options to remove correctly handle duplicates visually selected
            const indicesToRemoveInView = Array.from(selList.selectedOptions)
                                            .map(opt => parseInt(opt.dataset.index, 10))
                                            .filter(index => !isNaN(index));

            if (indicesToRemoveInView.length === 0) return; // Nothing selected to remove

            // Create a new list excluding items at the selected indices
            const newSelectedItems = [];
            for (let i = 0; i < selectedItems.length; i++) {
                if (!indicesToRemoveInView.includes(i)) {
                    newSelectedItems.push(selectedItems[i]);
                }
            }
            selectedItems = newSelectedItems; // Update the master list
            renderSelected(); // Re-render the selection box
        }


        function clearSelected() {
            selectedItems = [];
            renderSelected();
        }

        populateAvailable();

        filterInput.addEventListener('input', populateAvailable);
        addBtn.addEventListener('click', addSelected);
        remBtn.addEventListener('click', removeSelected);
        clearBtn.addEventListener('click', clearSelected);
        selList.addEventListener('keydown', e => {
            if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); removeSelected(); }
        });
        selList.addEventListener('dblclick', removeSelected);
        availList.addEventListener('dblclick', addSelected);


        return { getSelectedItems: () => [...selectedItems], clear: clearSelected }; // Return a copy
    }


    // --- Condensing Logic (unchanged) ---
    function getPartId(code) {
        const match = code.match(/\{(\d+)/);
        return match ? match[1] : null;
    }

   function condenseParts(parts) {
         if (!parts || parts.length === 0) return [];

         const grouped = {};
         const individualParts = [];

         parts.forEach(code => {
             const match = code.match(/^\{(\d+)(:\s*([^}\[\]]+)|:\s*\[([^\]]+)\])?\s*\}$/);
             if (match) {
                 const id = match[1];
                 if (!grouped[id]) grouped[id] = [];
                 grouped[id].push(code.trim());
             } else if (typeof code === 'string' && code.trim().length > 0 && !code.includes('||')) {
                  individualParts.push(code.trim());
             }
         });

         const condensedParts = [];

         for (const id in grouped) {
             const codes = grouped[id];
             if (codes.length === 1) {
                 condensedParts.push(codes[0]);
             } else {
                 let values = [];
                 let isSimpleIdOnly = true;
                 let malformedFound = false; // Flag for parts within the group that didn't parse correctly

                 codes.forEach(code => {
                     const valueMatch = code.match(/:\s*([^}\[\]]+)\s*\}$/);
                     const arrayMatch = code.match(/:\s*\[([^\]]+)\]\s*\}$/);
                     const simpleIdMatch = code.match(/^\{(\d+)\}$/);

                     if (arrayMatch) {
                         values.push(...arrayMatch[1].trim().split(/\s+/).filter(v => v));
                         isSimpleIdOnly = false;
                     } else if (valueMatch) {
                         values.push(valueMatch[1].trim());
                         isSimpleIdOnly = false;
                     } else if (!simpleIdMatch) {
                          individualParts.push(code); // Treat as individual if format unclear
                          malformedFound = true; // Mark that this group had issues
                     }
                     // If it *is* a simpleIdMatch, isSimpleIdOnly remains true initially
                 });

                 // If malformed parts were found and moved, don't try to condense the rest of this group
                 if (malformedFound) continue;

                 if (isSimpleIdOnly && codes.length > 0) {
                      condensedParts.push(codes[0]); // Only simple {ID}s, add first one
                 } else if (values.length > 0) {
                     const uniqueValues = [...new Set(values)];
                     if (uniqueValues.length === 1 && codes.length > 1) {
                          condensedParts.push(`{${id}:[${uniqueValues[0]}]}`);
                     } else if (uniqueValues.length > 0) {
                          condensedParts.push(`{${id}:[${uniqueValues.join(' ')}]}`);
                     } else if (codes.length > 0 && !isSimpleIdOnly) { // Has : but no value extracted? Unlikely.
                          condensedParts.push(codes[0]); // Fallback
                     }
                 } else if (codes.length > 0 && !isSimpleIdOnly) {
                      condensedParts.push(codes[0]);
                 }
             }
         }

         return [...condensedParts, ...individualParts];
     }


    // --- Output Rebuilding & API ---
    function rebuildOutput() {
        try {
            // 1. Determine Base Header and Base Dynamic Parts
            let baseHeader = '';
            let baseDynamicParts = [];
            const baseInput = currentBaseInputString.trim(); // Use the applied base string

            if (baseInput) {
                const headerMatch = baseInput.match(/^([^\{]*\|\|\s*)/);
                if (headerMatch) {
                    baseHeader = headerMatch[0].trim();
                    const remaining = baseInput.substring(headerMatch[0].length).trim().replace(/\|+$/, '').trim(); // Remove trailing pipes
                    baseDynamicParts = remaining ? remaining.split(/\s+/).filter(p => p.length > 0) : [];
                } else {
                     const firstBlockIndex = baseInput.indexOf('{');
                     if (firstBlockIndex === 0) {
                         baseHeader = '';
                         const remaining = baseInput.replace(/\|+$/, '').trim();
                         baseDynamicParts = remaining ? remaining.split(/\s+/).filter(p => p.length > 0) : [];
                     } else if (firstBlockIndex > 0) {
                          baseHeader = baseInput.substring(0, firstBlockIndex).trim();
                          const remaining = baseInput.substring(firstBlockIndex).trim().replace(/\|+$/, '').trim();
                          baseDynamicParts = remaining ? remaining.split(/\s+/).filter(p => p.length > 0) : [];
                     } else {
                          baseHeader = baseInput.replace(/\|+$/, '').trim(); // Treat whole input as header if no parts
                          baseDynamicParts = [];
                     }
                }
            } else {
                 // Generate Base Header if no input applied
                const typeMap = { gun: 1, shield: 2, grenade: 3, classmod: 4, enhancement: 5 };
                const itemTypeId = typeMap[dom.itemTypeSel.value] || 0;
                rndSeed = Math.floor(1000 + Math.random() * 9000); // New seed for generated header
                baseHeader = `${itemTypeId}, 0, 1, 50| 2, ${rndSeed}||`;
                 const rarityCodeMap = { common: 217, uncommon: 218, rare: 219, epic: 220, legendary: 999 };
                 const rarityPart = `{${rarityCodeMap[dom.raritySel.value] || 0}}`;
                 baseDynamicParts.push(rarityPart); // Add default rarity if generating
            }

            // 2. Collect parts from ALL builders
            let builderPartsRaw = [];
            Object.values(builders).forEach(builder => {
                if (typeof builder.getSelectedItems === 'function') {
                    builderPartsRaw.push(...builder.getSelectedItems());
                }
            });
            const builderPartsSet = new Set(builderPartsRaw); // Set for quick lookups

            // 3. Condense all parts (base dynamic + builder)
            const allPartsToCondense = [...baseDynamicParts, ...builderPartsRaw];
            const condensedParts = condenseParts(allPartsToCondense); // Use the original full list for condensation logic

             // 4. Build Output HTML, highlighting ONLY added parts (green)
             //    Duplicate highlighting is now done on-demand
             let outputHtml = '';
             if (baseHeader) {
                 outputHtml += baseHeader; // Add header first
             }

             // --- Use the UNCONDENSED parts list to determine highlighting correctly ---
             const finalPartsList = baseHeader ? [baseHeader, ...condensedParts] : [...condensedParts];
             let currentHtmlOutput = '';
             finalPartsList.forEach((partStr, index) => {
                  // Determine if this part (or its components if array) was added by a builder
                  let isAdded = false;
                  const arrayMatch = partStr.match(/^\{(\d+):\s*\[([^\]]+)\]\s*\}$/);
                  if (arrayMatch) {
                      const id = arrayMatch[1];
                      const values = arrayMatch[2].trim().split(/\s+/);
                      // Check if ANY original part contributing to this array was from a builder
                      isAdded = values.some(val => builderPartsRaw.includes(`{${id}:${val}}`));
                      if (!isAdded) isAdded = builderPartsRaw.includes(`{${id}}`); // Check if simple {ID} was added and condensed
                      // Also check if the raw array string itself was added (less likely but possible)
                      if (!isAdded) isAdded = builderPartsRaw.includes(partStr);
                  } else {
                      isAdded = builderPartsSet.has(partStr); // Check if the exact string was added
                  }

                 // Add space before part if needed
                 if ((baseHeader || index > 0) && currentHtmlOutput.length > 0 && !currentHtmlOutput.endsWith(' ')) {
                      currentHtmlOutput += ' ';
                 }

                 // Append part with green highlight if added
                 if (isAdded) {
                     currentHtmlOutput += `<span class="added-part">${partStr}</span>`;
                 } else {
                     currentHtmlOutput += partStr;
                 }
             });
             outputHtml = currentHtmlOutput;


            // 5. Add final pipe correctly
            let finalOutputStringForPipeCheck = outputHtml.replace(/<[^>]*>/g, '').trim(); // Get text version for logic check
            if (condensedParts.length > 0 && !finalOutputStringForPipeCheck.endsWith('|')) {
                 outputHtml += '|'; // Add trailing pipe if parts exist after header and pipe isn't already there
            } else if (!baseHeader && condensedParts.length > 0 && !finalOutputStringForPipeCheck.endsWith('|')) {
                 outputHtml += '|'; // Add trailing pipe if no header but parts exist
            }

             // Cleanup potential multiple spaces ONLY IN TEXT for storage
             lastGeneratedOutput = outputHtml.replace(/<[^>]*>/g, '').replace(/\s{2,}/g, ' ').trim();

            // Update output display if not manually editing
            if (document.activeElement !== dom.outCode) {
                 dom.outCode.innerHTML = outputHtml; // Render HTML
                 // If we rebuild automatically, turn off manual edit mode
                 if (isManualEditMode) {
                     isManualEditMode = false;
                     dom.outCode.classList.remove('manual-edit');
                     dom.outWrapper.classList.remove('manual-edit');
                     dom.outWrapper.querySelector('.manual-edit-indicator').style.display = 'none';
                 }
            }
             // Clear duplicate info on automatic rebuild
             dom.duplicateInfo.innerHTML = '';

             // Ensure message area is hidden unless an error occurs later
             if (dom.messageArea.style.display !== 'none' && !dom.messageArea.classList.contains('error')) {
                 dom.messageArea.style.display = 'none';
             }

        } catch (err) {
            showMessage(`Error generating output: <code>${err.message}</code>. Check builder setup and data.`, 'error');
            console.error("Output Generation Error:", err);
            dom.outCode.innerHTML = '[Error generating output]'; // Use innerHTML here too
            lastGeneratedOutput = '';
            dom.duplicateInfo.innerHTML = ''; // Clear duplicates on error
        }
    }

    // --- NEW: On-Demand Duplicate Analysis and Highlighting ---
    function analyzeAndHighlightDuplicates() {
         const outputText = lastGeneratedOutput; // Use the last generated plain text
         if (!outputText || outputText.startsWith('[')) {
             showMessage('No valid output string to analyze.', 'info');
             dom.duplicateInfo.innerHTML = '';
             return;
         }

         // 1. Parse into header and parts (similar to rebuildOutput start)
         let baseHeader = '';
         let partsToAnalyze = [];
         const headerMatch = outputText.match(/^([^\{]*\|\|\s*)/);
         if (headerMatch) {
             baseHeader = headerMatch[0].trim();
             const remaining = outputText.substring(headerMatch[0].length).trim().replace(/\|+$/, '').trim();
             partsToAnalyze = remaining ? remaining.split(/\s+/).filter(p => p.length > 0) : [];
         } else {
             const firstBlockIndex = outputText.indexOf('{');
             if (firstBlockIndex === 0) {
                 baseHeader = '';
                 const remaining = outputText.replace(/\|+$/, '').trim();
                 partsToAnalyze = remaining ? remaining.split(/\s+/).filter(p => p.length > 0) : [];
             } else if (firstBlockIndex > 0) {
                 baseHeader = outputText.substring(0, firstBlockIndex).trim();
                 const remaining = outputText.substring(firstBlockIndex).trim().replace(/\|+$/, '').trim();
                 partsToAnalyze = remaining ? remaining.split(/\s+/).filter(p => p.length > 0) : [];
             } else {
                 baseHeader = outputText.replace(/\|+$/, '').trim();
                 partsToAnalyze = [];
             }
         }

         // 2. Count Duplicates according to specific rules
         const simpleBlockCounts = {}; // Counts for {ID}
         const valueBlockCounts = {};  // Counts for {ID:Value}
         const arrayValueCounts = {};  // Counts for Value within {ID:[...]}, structure: { arrayId: { value: count } }

         partsToAnalyze.forEach(partStr => {
             const simpleMatch = partStr.match(/^\{(\d+)\}$/);
             const valueMatch = partStr.match(/^\{(\d+):\s*([^}\[\]\s]+)\s*\}$/); // Only single values
             const arrayMatch = partStr.match(/^\{(\d+):\s*\[([^\]]+)\]\s*\}$/);

             if (simpleMatch) {
                 const id = simpleMatch[0]; // Use full string as key
                 simpleBlockCounts[id] = (simpleBlockCounts[id] || 0) + 1;
             } else if (valueMatch) {
                 const idVal = valueMatch[0]; // Use full string as key
                 valueBlockCounts[idVal] = (valueBlockCounts[idVal] || 0) + 1;
             } else if (arrayMatch) {
                 const id = arrayMatch[1];
                 const values = arrayMatch[2].trim().split(/\s+/).filter(v => v);
                 if (!arrayValueCounts[id]) {
                     arrayValueCounts[id] = {};
                 }
                 values.forEach(val => {
                     arrayValueCounts[id][val] = (arrayValueCounts[id][val] || 0) + 1;
                 });
             }
         });

         // Filter to get only the duplicates
         const duplicateSimpleBlocks = Object.entries(simpleBlockCounts).filter(([_, count]) => count > 1);
         const duplicateValueBlocks = Object.entries(valueBlockCounts).filter(([_, count]) => count > 1);
         const duplicateArrayValues = Object.entries(arrayValueCounts)
             .map(([id, valueCounts]) => ({
                 id,
                 duplicates: Object.entries(valueCounts).filter(([_, count]) => count > 1)
             }))
             .filter(entry => entry.duplicates.length > 0);

         // 3. Generate Report HTML
         let duplicatesHtml = '<h4>Duplicate Parts Info</h4>';
         let foundDuplicates = false;

         if (duplicateSimpleBlocks.length > 0) {
             duplicatesHtml += `<div class="duplicate-category"><h5>Blocks repeated:</h5>`;
             duplicateSimpleBlocks.forEach(([block, count]) => {
                 duplicatesHtml += `<span class="duplicate-entry"><span class="dup-block-simple">${block}</span>: ${count} times</span>`;
             });
             duplicatesHtml += `</div>`;
             foundDuplicates = true;
         }
          if (duplicateValueBlocks.length > 0) {
             duplicatesHtml += `<div class="duplicate-category"><h5>Value Blocks repeated:</h5>`;
             duplicateValueBlocks.forEach(([block, count]) => {
                 duplicatesHtml += `<span class="duplicate-entry"><span class="dup-block-value">${block}</span>: ${count} times</span>`;
             });
              duplicatesHtml += `</div>`;
             foundDuplicates = true;
         }
         if (duplicateArrayValues.length > 0) {
             duplicatesHtml += `<div class="duplicate-category"><h5>Values repeated within Arrays:</h5>`;
             duplicateArrayValues.forEach(({ id, duplicates }) => {
                  duplicates.forEach(([val, count]) => {
                       duplicatesHtml += `<span class="duplicate-entry">{${id}:[...<span class="dup-array-value">${val}</span>...]}: ${count} times</span>`;
                  });
             });
              duplicatesHtml += `</div>`;
             foundDuplicates = true;
         }

         if (!foundDuplicates) {
             duplicatesHtml += '<div>None</div>';
         }
         dom.duplicateInfo.innerHTML = duplicatesHtml;

         // 4. Regenerate Output HTML with Specific Highlights
         let outputHtml = '';
         if (baseHeader) outputHtml += baseHeader;

         // Get original builder parts for green highlighting check
          let builderPartsRaw = [];
          Object.values(builders).forEach(builder => {
              if (typeof builder.getSelectedItems === 'function') {
                  builderPartsRaw.push(...builder.getSelectedItems());
              }
          });
          const builderPartsSet = new Set(builderPartsRaw);

         partsToAnalyze.forEach((partStr, index) => {
             // Add space
             if ((baseHeader || index > 0) && outputHtml.length > 0 && !outputHtml.endsWith(' ')) {
                  outputHtml += ' ';
             }

             const simpleMatch = partStr.match(/^\{(\d+)\}$/);
             const valueMatch = partStr.match(/^\{(\d+):\s*([^}\[\]\s]+)\s*\}$/);
             const arrayMatch = partStr.match(/^\{(\d+):\s*\[([^\]]+)\]\s*\}$/);
             let highlighted = false;

             if (simpleMatch && simpleBlockCounts[partStr] > 1) {
                 outputHtml += `<span class="dup-block-simple">${partStr}</span>`; // Blue
                 highlighted = true;
             } else if (valueMatch && valueBlockCounts[partStr] > 1) {
                 outputHtml += `<span class="dup-block-value">${partStr}</span>`; // Orange
                 highlighted = true;
             } else if (arrayMatch) {
                 const id = arrayMatch[1];
                 const valuesStr = arrayMatch[2];
                 const values = valuesStr.trim().split(/\s+/).filter(v => v);
                 let arrayInnerHtml = '';
                 values.forEach((val, valIndex) => {
                     if (valIndex > 0) arrayInnerHtml += ' ';
                     if (arrayValueCounts[id]?.[val] > 1) {
                         arrayInnerHtml += `<span class="dup-array-value">${val}</span>`; // Yellow
                     } else {
                         arrayInnerHtml += val;
                     }
                 });
                 // Check if the overall block contained *any* yellow highlight
                 highlighted = arrayInnerHtml.includes('dup-array-value');
                 // Apply green if added and no yellow applied? Or skip green if any yellow? Let's skip green if yellow is present.
                  let isAdded = values.some(val => builderPartsRaw.includes(`{${id}:${val}}`)) || builderPartsRaw.includes(`{${id}}`) || builderPartsRaw.includes(partStr);
                  if (!highlighted && isAdded){
                       outputHtml += `{${id}:[<span class="added-part">${arrayInnerHtml}</span>]}`; // Wrap whole inner content in green if added and no duplicates
                       highlighted = true; // Mark as highlighted (green)
                  } else {
                       outputHtml += `{${id}:[${arrayInnerHtml}]}`;
                  }

             }

             // Apply green if added by builder AND not already highlighted as duplicate
             if (!highlighted) {
                  let isAdded = builderPartsSet.has(partStr);
                  // Additional check for parts that might have been condensed into an array
                  if (!isAdded && (simpleMatch || valueMatch)) {
                      // Check if this simple/value block was part of a group that got condensed
                      // This is complex to track perfectly without modifying condenseParts significantly
                      // For simplicity, we rely on the builderPartsSet check for non-array blocks
                  }

                 if (isAdded) {
                     outputHtml += `<span class="added-part">${partStr}</span>`;
                 } else {
                     outputHtml += partStr;
                 }
             }
         });

         // Add final pipe
          let finalOutputStringForPipeCheck = outputHtml.replace(/<[^>]*>/g, '').trim();
          if (partsToAnalyze.length > 0 && !finalOutputStringForPipeCheck.endsWith('|')) {
               outputHtml += '|';
          } else if (!baseHeader && partsToAnalyze.length > 0 && !finalOutputStringForPipeCheck.endsWith('|')) {
               outputHtml += '|';
          }

         dom.outCode.innerHTML = outputHtml; // Update display with highlights
         isManualEditMode = false; // Turn off manual edit mode after analysis
         dom.outCode.classList.remove('manual-edit');
         dom.outWrapper.classList.remove('manual-edit');
         dom.outWrapper.querySelector('.manual-edit-indicator').style.display = 'none';

         showMessage('Duplicate analysis complete.', 'success');
    }

    // --- Debounced Triggers and API Logic ---
    function triggerDebouncedRebuild() {
         clearTimeout(rebuildTimer);
         rebuildTimer = setTimeout(rebuildOutputAndCallApi, 50);
    }
    function triggerDebouncedApiCall() {
         clearTimeout(apiCallTimer);
         if (!isManualEditMode) {
             apiCallTimer = setTimeout(callReserialize, 400);
         }
    }
    function rebuildOutputAndCallApi() {
        rebuildOutput(); // This now ONLY applies green highlights
        triggerDebouncedApiCall();
    }

    async function callReserialize() {
      if (dom.serial_b85) dom.serial_b85.textContent = 'Fetching...';
      if (dom.additionalData) dom.additionalData.textContent = '';
      dom.copySerial.disabled = true;

      try {
        const outText = lastGeneratedOutput; // Use the stored text version for API call

        if (!outText || outText === '[Error generating output]' || !outText.endsWith('|')) {
          if (dom.serial_b85) dom.serial_b85.textContent = '[No valid serial to send]';
           showMessage('Cannot call API: Output serial is invalid or empty.', 'error');
          return;
        }

        const resp = await fetch('https://borderlands4-deserializer.nicnl.com/api/v1/reserialize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ deserialized: outText })
        });

        if (!resp.ok) {
            let errorText = `HTTP ${resp.status} - ${resp.statusText}`;
            try { const errorData = await resp.json(); errorText += `: ${errorData.error || errorData.message || 'Unknown API error'}`; }
            catch (_) {}
            throw new Error(errorText);
        }

        const data = await resp.json();
        if (dom.serial_b85) dom.serial_b85.textContent = data.serial_b85 || '[No serial returned]';
        if (dom.additionalData) dom.additionalData.textContent = data.additional_data || '[No details]';
        dom.copySerial.disabled = !data.serial_b85;

      } catch (err) {
        console.error('Reserialize API error:', err);
        if (dom.serial_b85) dom.serial_b85.textContent = `[API error: ${err.message}]`;
        if (dom.additionalData) dom.additionalData.textContent = '';
        dom.copySerial.disabled = true;
        if (!err.message.includes('aborted')) {
             showMessage(`API Error: ${err.message}`, 'error');
        }
      }
    }

    // --- NEW: Input Handling Functions ---
    async function deserializeSerial() {
        const input = dom.baseSerial.value.trim();
        if (!input) {
            showMessage('Please enter a serial code to deserialize', 'info');
            return;
        }
        if (!input.startsWith('@U')) {
             showMessage('Input must be a game serial starting with @U to use Deserialize.', 'error');
             return;
        }
        showMessage('Deserializing via API...', 'info');
        try {
            const response = await fetch(`${API_BASE_URL}/deserialize_bulk`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify([input]) // Send as array
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Deserialize API error: ${response.status} - ${errorText}`);
            }
            const result = await response.json();
            const firstKey = Object.keys(result)[0];
            if (result[firstKey] && result[firstKey].deserialized) {
                const deserialized = result[firstKey].deserialized;
                dom.baseSerial.value = deserialized; // Update textarea
                currentBaseInputString = deserialized; // Store immediately
                showMessage('‚úÖ Deserialization successful! Click "Apply Code Block" to use.', 'success');
                rebuildOutputAndCallApi(); // Rebuild with the new base
            } else {
                throw new Error(result[firstKey]?.error || 'Deserialization failed: Unknown API response');
            }
        } catch (error) {
            showMessage('Deserialization failed: ' + error.message, 'error');
        }
    }

    function applyInput() {
         const input = dom.baseSerial.value.trim();
         if (!input) {
             currentBaseInputString = ''; // Clear base if input is empty
             showMessage('Base input cleared. Generating default header.', 'info');
             rebuildOutputAndCallApi();
             return;
         }
         if (input.startsWith('@U')) {
            showMessage('‚ö†Ô∏è Cannot apply game serial directly. Click "Deserialize Serial Code" first.', 'error');
            return;
         }
         const deserializedPattern = /(\|\|\s*)|(\{)/; // Basic check for || or {
         if (!deserializedPattern.test(input)) {
             showMessage('‚ö†Ô∏è Invalid format. Expected deserialized code block (containing || or { }).', 'error');
             return;
         }
         currentBaseInputString = input; // Store the validated input
         showMessage('‚úÖ Base code block applied.', 'success');
         rebuildOutputAndCallApi(); // Rebuild with the new base
    }

    // --- Collapsible Sections ---
    function setupCollapsibleSections() {
        document.querySelectorAll('.collapsible').forEach(section => {
            const header = section.querySelector('h2') || section.querySelector('.row.titleRow > div:first-child');
            const content = section.querySelector('.collapsible-content');
            const titleRow = section.querySelector('.row.titleRow');
            if (!header || !content) {
                 console.warn("Collapsible section missing header or content:", section);
                 return;
            }
            const toggleBtn = document.createElement('button');
            toggleBtn.textContent = '+';
            toggleBtn.className = 'toggle-btn small';
            toggleBtn.title = 'Expand/Collapse Section';
             if (titleRow) {
                 titleRow.appendChild(toggleBtn);
             } else if (header.tagName === 'H2') {
                 header.insertAdjacentElement('afterend', toggleBtn);
                 header.style.display = 'inline-block';
                 toggleBtn.style.marginLeft = '10px';
             } else {
                 header.parentNode.insertBefore(toggleBtn, header.nextSibling);
             }
            toggleBtn.addEventListener('click', () => {
                const isExpanded = content.classList.toggle('expanded');
                toggleBtn.textContent = isExpanded ? '‚àí' : '+';
                toggleBtn.classList.toggle('expanded-btn', isExpanded);
            });
        });
    }

    // --- Initialization ---
    async function initializeApp() {
        dom.body.classList.add('loading');
        try {
            const response = await fetch('bl4_parts_data.json');
            if (!response.ok) throw new Error(`HTTP error ${response.status} fetching <code>bl4_parts_data.json</code>.`);

            try { PAYLOAD = await response.json(); }
            catch (jsonError) { throw new Error(`Failed to parse <code>bl4_parts_data.json</code>: ${jsonError.message}.`); }

            const requiredKeys = ['altFireModes', 'magazineModes', 'legendaryPerks', 'ordnancePerks'];
            const missingKeys = requiredKeys.filter(key => !PAYLOAD[key] || !Array.isArray(PAYLOAD[key]));
            if (missingKeys.length > 0) throw new Error(`Data Validation Error: Key(s) <code>${missingKeys.join(', ')}</code> missing/invalid in JSON.`);

            // Initialize builders
            document.querySelectorAll('.builderSection').forEach(section => {
                 const key = section.dataset.key;
                 const nameField = section.dataset.nameField;
                 const codeField = section.dataset.codeField;
                 const idPrefix = section.dataset.idPrefix;
                 if (key && nameField && codeField && idPrefix && PAYLOAD[key]) {
                     try { builders[key] = createBuilder(key, nameField, codeField, idPrefix); }
                     catch (builderError) { throw new Error(`Failed to init builder for ${key}: ${builderError.message}`); }
                 } else { console.warn("Skipping builder section, missing data attributes or data not found in PAYLOAD:", section, key); }
            });

            setupCollapsibleSections();

            // --- Setup Event Listeners ---
            dom.itemTypeSel.addEventListener('change', triggerDebouncedRebuild);
            dom.raritySel.addEventListener('change', triggerDebouncedRebuild);

            // NEW Input listeners
            dom.applyInputBtn.addEventListener('click', applyInput);
            dom.deserializeBtn.addEventListener('click', deserializeSerial);

            // Manual Edit Handling
            dom.outCode.addEventListener('input', () => {
                isManualEditMode = true;
                dom.outCode.classList.add('manual-edit');
                dom.outWrapper.classList.add('manual-edit');
                dom.outWrapper.querySelector('.manual-edit-indicator').style.display = 'inline';
                // Clear highlights when manual editing starts
                const text = dom.outCode.textContent;
                dom.outCode.innerHTML = text; // Replace HTML with plain text
                clearTimeout(apiCallTimer); // Stop automatic API calls
                dom.duplicateInfo.innerHTML = ''; // Clear duplicate info
            });

            dom.undoEditBtn.addEventListener('click', () => {
                if (lastGeneratedOutput) {
                    currentBaseInputString = dom.baseSerial.value.trim();
                    rebuildOutput(); // Regenerates green highlights
                    isManualEditMode = false;
                    dom.outCode.classList.remove('manual-edit');
                    dom.outWrapper.classList.remove('manual-edit');
                    dom.outWrapper.querySelector('.manual-edit-indicator').style.display = 'none';
                    triggerDebouncedApiCall();
                    showMessage('Manual edit undone.', 'info');
                    dom.duplicateInfo.innerHTML = ''; // Clear duplicate info
                } else {
                    showMessage('No previous output to restore!', 'error');
                }
            });

            dom.reserializeManualBtn.addEventListener('click', callReserialize);
            dom.analyzeDuplicatesBtn.addEventListener('click', analyzeAndHighlightDuplicates); // Add listener for analyze button

            // Copy Buttons
             dom.copyFull.addEventListener('click', async () => {
                 const outputElement = dom.outCode;
                 const textToCopy = outputElement.textContent.trim();
                try {
                    if (!textToCopy || textToCopy.startsWith('[')) return showMessage('No output to copy!', 'info');
                    await navigator.clipboard.writeText(textToCopy);
                    showMessage('Output copied!', 'success');
                } catch(e) { console.error('Copy Output failed:', e); showMessage('Copy failed!', 'error'); }
             });
             dom.copySerial.addEventListener('click', async () => {
                 const outputElement = dom.serial_b85;
                 const textToCopy = outputElement.textContent.trim();
                try {
                     if (!textToCopy || textToCopy.startsWith('[')) return showMessage('No API serial to copy!', 'info');
                    await navigator.clipboard.writeText(textToCopy);
                     showMessage('API Serial copied!', 'success');
                } catch(e) { console.error('Copy API Serial failed:', e); showMessage('Copy failed!', 'error'); }
             });

            // Initial build and API call
            applyInput(); // Apply initial textarea content (likely empty)

        } catch (error) {
             showMessage(`Initialization Error: ${error.message}`, 'error');
             // Consider disabling parts of the UI if init fails catastrophically
             document.querySelectorAll('#mainContent button, #mainContent select, #applyInputBtn, #deserializeBtn').forEach(el => el.disabled = true);
        } finally {
             dom.body.classList.remove('loading');
        }
    }

    // Start the app
    document.addEventListener('DOMContentLoaded', initializeApp);

</script>
</body>
</html>

