<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport"/>
    <title>BL4 Weapon Part Editor (Hosted)</title>
    <style>
        /* Base styles adapted from Enhancement_Editor.html */
        :root { --bg:#0b0f14; --card:#0e1520; --ink:#e6f0ff; --muted:#a6b4c8; --line:#1f2a3a; --accent-orange: #e59400; --danger-red: #e74c3c; --success-green: #28a745; --edit-yellow: #ffc107; }
        * { box-sizing: border-box; }
        body { font-family: 'Inter', system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--bg); color: var(--ink); padding: 0; /* Remove body padding */ font-size: 16px; line-height: 1.5; margin: 0; }

        /* --- TAB NAVIGATION STYLES --- */
        .tab-nav { background-color: var(--card); border-bottom: 1px solid var(--line); padding: 0 18px; margin-bottom: 18px; display: flex; gap: 10px; }
        .tab-link { display: inline-block; padding: 12px 16px; color: var(--muted); text-decoration: none; border-bottom: 3px solid transparent; transition: color 0.2s ease, border-color 0.2s ease; font-weight: 500; font-size: 15px; }
        .tab-link:hover { color: var(--ink); }
        .tab-link.active { color: var(--accent-orange); border-bottom-color: var(--accent-orange); }
        /* --- END TAB STYLES --- */

        .container { max-width: 1200px; margin: 0 auto; padding: 0 18px 18px 18px; /* Padding moved here */ }
        h2 { margin: 0 0 14px; border-bottom: 1px solid var(--line); padding-bottom: 8px; font-weight: 700; display: flex; justify-content: space-between; align-items: center; } /* Make h2 a flex container */
        .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
        .card { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 14px 16px; display: flex; flex-direction: column; margin-bottom: 14px; }
        label { color: var(--muted); font-size: 12px; display: block; margin-bottom: 6px; font-weight: 400; }
        select, input, button, textarea { background: #0f1720; color: var(--ink); border: 1px solid var(--line); border-radius: 10px; padding: 10px 12px; font-size: 16px; font-family: inherit; }
        input::placeholder, textarea::placeholder { color: var(--muted); opacity: 0.7; }
        select[multiple] { padding: 4px; }
        select:focus, input:focus, button:focus, textarea:focus { outline: 2px solid var(--accent-orange); outline-offset: 1px; border-color: var(--accent-orange); }
        code { background:#0c121b; border: 1px solid var(--line); padding: 4px 8px; display: inline-block; border-radius: 6px; font-size: 0.9em; font-family: monospace; }
        button { cursor: pointer; background-color: #2c2c4d; transition: background-color 0.2s ease; margin-right: 5px; /* Added slight margin */}
        button:last-of-type { margin-right: 0; } /* Remove margin on last button in a group */
        button:hover { background-color: #4b4b7d; }
        button:disabled { background-color: #2c2c4d; opacity: 0.5; cursor: not-allowed; }
        button.small { padding: 6px 10px; border-radius: 8px; font-size: 14px; min-height: 38px; min-width: 38px; }
        .wrap { white-space: normal; word-break: break-word; }
        #baseSerial {
            width: 100%;
            min-height: 80px; /* Slightly taller */
            margin-top: 6px;
            font-family: monospace;
            font-size: 0.9em;
            resize: vertical;
        }
        .input-button-group { margin-top: 10px; } /* Space above buttons */

        /* --- COLLAPSIBLE STYLES --- */
        .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; margin-top: 0; }
        .collapsible-content.expanded { max-height: 1000px; /* Adjust if content is larger */ margin-top: 14px; }
        .toggle-btn { background: none; border: none; color: var(--muted); font-size: 1.5em; line-height: 1; padding: 0 5px; cursor: pointer; opacity: 0.7; transition: opacity 0.2s, color 0.2s; margin-left: 10px; }
        .toggle-btn:hover { opacity: 1; }
        .toggle-btn::before { content: '[+]'; color: var(--success-green); }
        .toggle-btn.expanded::before { content: '[-]'; color: var(--danger-red); }
        .builderSection .row.titleRow { justify-content: space-between; align-items: center; padding-bottom: 8px; margin-bottom: 0; border-bottom: 1px solid var(--line); }
        .builderSection .row.titleRow > div:first-child { font-weight: 700; color: var(--muted); font-size: 1.1em; border-bottom: none; padding-bottom: 0; margin-bottom: 0; flex-grow: 1; }
        .builderSection .row.filterRow { flex-grow: 0; flex-shrink: 0; width: auto; }
        /* --- END COLLAPSIBLE STYLES --- */

        /* Builder Styles */
        .builderSection .row.selects { margin-top: 8px; display: flex; gap: 10px; align-items: stretch; }
        .builderSection select { flex: 1; min-height: 220px; width: 100%; border-radius: 8px;}
        .builderSection .buttons { display: flex; flex-direction: column; gap: 8px; justify-content: center; width: 56px; align-items: center; }
        .builderSection .tip { margin-top: 10px; font-size: 12px; color: var(--muted); }

        /* Output Card Styles */
        .outCard code { display: block; overflow: auto; width: 100%; white-space: pre-wrap; word-break: break-all; max-height: 100px; min-height: 50px; background: #0c121b; padding: 10px; border-radius: 8px; border: 2px solid var(--line); transition: border-color 0.3s ease; }
        .outCard code[contenteditable="plaintext-only"] { /* Changed from true */ outline: none; }
        .outCard code[contenteditable="plaintext-only"]:focus { border-color: var(--edit-yellow); } /* Changed from true */
        .outCard code.manual-edit { border-color: var(--edit-yellow); }
        #apiCard code { max-height: 100px; }
        .sticky { position: sticky; top: 0; z-index: 20; background: var(--bg); }
        #message-area { padding: 10px 18px; margin-bottom: 14px; border-radius: 8px; font-size: 14px; display: none; border: 1px solid transparent; } /* Kept for fallback, but toasts preferred */
        #message-area.visible { display: block; }
        #message-area.error { background-color: rgba(231, 76, 60, 0.2); border-color: var(--danger-red); color: var(--danger-red); }
        #message-area.success { background-color: rgba(40, 167, 69, 0.2); border-color: var(--success-green); color: var(--success-green); }
        .copy-status { font-size: 12px; color: var(--muted); margin-left: 5px; opacity: 0; transition: opacity 0.3s ease; }
        .copy-status.visible { opacity: 1; }
        .manual-edit-indicator { display: none; font-size: 11px; color: var(--edit-yellow); margin-left: 8px; }
        .outCard.manual-edit .manual-edit-indicator { display: inline; }

        /* Style for scrollable API output */
        #serial_b85 {
            display: block; /* Ensure it behaves like a block for overflow */
            overflow: auto; /* Add scrollbars when needed */
            max-height: 100px; /* Match max-height of main output */
            white-space: pre-wrap; /* Allow wrapping */
            word-break: break-all; /* Break long strings */
        }
        /* END Style for scrollable API output */

        /* --- Style for Added Parts --- */
        .added-part {
            color: var(--success-green);
            font-weight: 500; /* Slightly bolder */
        }
        /* --- END Style --- */

        /* Message Toast Styles */
        .message-toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); display: none; align-items: center; gap: 10px; z-index: 10000; opacity: 0; transition: opacity 0.3s ease, bottom 0.3s ease; font-size: 15px; }
        .message-toast.show { display: flex; opacity: 1; bottom: 30px; }
        .message-toast.success { background: rgba(40, 167, 69, 0.9); border: 1px solid var(--success-green); color: #fff; }
        .message-toast.error { background: rgba(231, 76, 60, 0.9); border: 1px solid var(--danger-red); color: #fff; }
        .message-toast.info { background: rgba(44, 44, 77, 0.95); border: 1px solid var(--line); color: var(--ink); }
        .toast-icon { font-size: 1.2em; line-height: 1; }
        /* --- END Message Toast Styles --- */

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .tab-nav { padding: 0 10px; margin-bottom: 10px; }
            .tab-link { padding: 10px 8px; font-size: 14px; }
            .container { padding: 0 10px 10px 10px; }
            .outCard code { max-height: 120px; }
            .outCard .row { flex-wrap: wrap; }
            .outCard .row button.small { min-height: 30px; }
            #dice { padding: 4px 8px !important; font-size: 12px !important; }
            .builderSection .row.titleRow { flex-wrap: wrap; }
            .builderSection .row.filterRow { width: 100%; justify-content: space-between; margin-top: 5px;}
            .message-toast { width: calc(100% - 40px); left: 20px; transform: none; }
        }
    </style>
</head>
<body>

    <!-- TAB NAVIGATION BAR (Unchanged) -->
    <nav class="tab-nav">
        <a href="Deseralizer Comparator.html" class="tab-link">Comparator & Editor</a>
        <a href="Deseralizer Comparator.html#deserializer" class="tab-link">Deserializer</a>
        <a href="bl4_decoder.html" class="tab-link active">Workstation</a>
    </nav>

<div class="container">
    <div id="message-area"></div> <!-- Kept as fallback -->

    <h2>BL4 Weapon Part Editor (Workstation)</h2>

    <!-- Input Serial Section (Unchanged) -->
    <div class="card" id="inputCard">
        <label for="baseSerial">Input Base Serial String (@U or Deserialized)</label>
        <textarea id="baseSerial" rows="3" placeholder="Paste @U... serial (click Deserialize first) OR deserialized format like: 9, 0, 1, 50| 2, 1626|| {80} {2}|"></textarea>
        <div class="input-button-group">
            <button id="applyInputBtn">Apply Code Block</button> <!-- Renamed Button -->
            <button id="deserializeBtn">Deserialize Serial Code</button>
        </div>
        <p style="margin-top: 10px; opacity: 0.8; font-size: 0.9em; color: var(--muted);">
            If pasting a <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">@U...</code> serial, click "Deserialize" first, then "Apply Code Block".
        </p>
    </div>
    <!-- END Input Serial Section -->

    <!-- Output + API (Sticky) (Unchanged) -->
    <div class="card outCard sticky">
        <div class="row" style="justify-content: space-between; align-items: center;">
            <div style="color:var(--muted)">Output Serial String <span class="manual-edit-indicator">(Manual Edit Mode)</span></div>
            <div class="row">
                 <button class="small" id="reserializeManual" title="Reserialize Manual Edit">🔄 API</button>
                 <button class="small" id="undoEdit" title="Undo Manual Edit & Rebuild">↩️ Undo</button>
                 <button class="small" id="copyFull" title="Copy Output String">📋</button>
                 <span id="copyFullStatus" class="copy-status"></span>
            </div>
        </div>
        <div id="out" style="margin-top:6px"><code contenteditable="plaintext-only"><!-- Output code will appear here --></code></div>
         <button class="small" id="dice" title="New random seed" style="margin-top: 10px; width: fit-content;">🎲 New Seed</button>
    </div>

     <div class="card" id="apiCard" style="margin-bottom:14px">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
            <div>
                <div style="color:var(--muted)">Validated Serial (API Result)</div>
                <div id="serialWrap" style="margin-top:6px"><code id="serial_b85"><!-- API Serial B85 --></code></div>
                <div id="addDataWrap" style="margin-top:6px;color:var(--muted); font-size: 12px;">
                    <span style="opacity:.8">Details:</span> <code id="additionalData" style="font-size: 12px;"><!-- API Additional Data --></code>
                </div>
            </div>
            <div class="row" style="gap:8px">
                <button class="small" id="copySerial" title="Copy API Serial" disabled>📋</button>
                <span id="copyApiStatus" class="copy-status"></span>
            </div>
        </div>
    </div>

     <div id="mainContent">
        <!-- Base Item Card (Unchanged) -->
        <div class="card collapsible" id="baseItemCard">
             <h2>Base Item Properties</h2>
             <div class="collapsible-content">
                 <div class="row">
                    <div style="flex: 1;">
                        <label>Base Item Type (Placeholder)</label>
                        <select id="itemTypeSel">
                            <option value="gun">Generic Gun</option>
                            <option value="shield">Shield</option>
                            <option value="grenade">Grenade Mod</option>
                            <option value="classmod">Class Mod</option>
                            <option value="enhancement">Enhancement</option>
                        </select>
                    </div>
                     <div style="flex: 1;">
                        <label>Rarity (Placeholder)</label>
                        <select id="raritySel">
                            <option value="common">Common</option>
                            <option value="uncommon">Uncommon</option>
                            <option value="rare">Rare</option>
                            <option value="epic">Epic</option>
                            <option value="legendary">Legendary</option>
                        </select>
                    </div>
                 </div>
             </div>
        </div>
        <!-- Legendary Perks (Unchanged) -->
        <div class="card builderSection collapsible" data-key="legendaryPerks" data-name-field="name" data-code-field="code" data-id-prefix="LegPerk">
             <div class="row titleRow">
                 <div>Legendary Perk Part Variations</div>
                 <div class="row filterRow">
                    <input id="filterLegPerk" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearLegPerk" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availLegPerk" multiple size="8" aria-label="Available Legendary Perks"></select>
                    <div class="buttons">
                        <button id="addLegPerk" title="Add Selected">»</button>
                        <button id="remLegPerk" title="Remove Selected">«</button>
                    </div>
                    <select id="selLegPerk" multiple size="8" aria-label="Selected Legendary Perks"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
             </div>
        </div>
        <!-- Alt Fire Modes (Unchanged) -->
        <div class="card builderSection collapsible" data-key="altFireModes" data-name-field="name" data-code-field="code" data-id-prefix="AltFire">
            <div class="row titleRow">
                <div>Alt Fire Mode Variations</div>
                <div class="row filterRow">
                    <input id="filterAltFire" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearAltFire" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availAltFire" multiple size="8" aria-label="Available Alt Fire Modes"></select>
                    <div class="buttons">
                        <button id="addAltFire" title="Add Selected">»</button>
                        <button id="remAltFire" title="Remove Selected">«</button>
                    </div>
                    <select id="selAltFire" multiple size="8" aria-label="Selected Alt Fire Modes"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
            </div>
        </div>
        <!-- Magazine Modes (Unchanged) -->
        <div class="card builderSection collapsible" data-key="magazineModes" data-name-field="name" data-code-field="code" data-id-prefix="MagMode">
             <div class="row titleRow">
                <div>Magazine / Ammo Mode Variations</div>
                 <div class="row filterRow">
                    <input id="filterMagMode" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearMagMode" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availMagMode" multiple size="8" aria-label="Available Magazine/Ammo Modes"></select>
                    <div class="buttons">
                        <button id="addMagMode" title="Add Selected">»</button>
                        <button id="remMagMode" title="Remove Selected">«</button>
                    </div>
                    <select id="selMagMode" multiple size="8" aria-label="Selected Magazine/Ammo Modes"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
             </div>
        </div>

        <!-- ----- Elements Section ----- -->
        <div class="card builderSection collapsible" data-key="weaponElements" data-name-field="name" data-code-field="code" data-id-prefix="Elem">
             <div class="row titleRow">
                 <div>Elements</div>
                 <div class="row filterRow">
                    <input id="filterElem" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearElem" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availElem" multiple size="8" aria-label="Available Elements"></select>
                    <div class="buttons">
                        <button id="addElem" title="Add Selected">»</button>
                        <button id="remElem" title="Remove Selected">«</button>
                    </div>
                    <select id="selElem" multiple size="8" aria-label="Selected Elements"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Handles primary {1:X} and secondary {1:Y} element codes.</div>
             </div>
        </div>
        <!-- ----- END Elements Section ----- -->

        <!-- Ordnance Perks (Unchanged) -->
        <div class="card builderSection collapsible" data-key="ordnancePerks" data-name-field="name" data-code-field="code" data-id-prefix="OrdPerk">
             <div class="row titleRow">
                <div>Ordnance Legendary Perks (Heavy/Grenade)</div>
                 <div class="row filterRow">
                    <input id="filterOrdPerk" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearOrdPerk" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availOrdPerk" multiple size="8" aria-label="Available Ordnance Perks"></select>
                    <div class="buttons">
                        <button id="addOrdPerk" title="Add Selected">»</button>
                        <button id="remOrdPerk" title="Remove Selected">«</button>
                    </div>
                    <select id="selOrdPerk" multiple size="8" aria-label="Selected Ordnance Perks"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Condenses multiple identical IDs.</div>
             </div>
        </div>

        <!-- ----- Skins/Camo Section ----- -->
        <div class="card builderSection collapsible" data-key="weaponSkins" data-name-field="name" data-code-field="code" data-id-prefix="Skin">
             <div class="row titleRow">
                 <div>Skins / Camo</div>
                 <div class="row filterRow">
                    <input id="filterSkin" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearSkin" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availSkin" multiple size="8" aria-label="Available Weapon Skins"></select>
                    <div class="buttons">
                        <button id="addSkin" title="Add Selected">»</button>
                        <button id="remSkin" title="Remove Selected">«</button>
                    </div>
                    <select id="selSkin" multiple size="8" aria-label="Selected Weapon Skins"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Note: Skins often use specific block formats like `"c", XX|`. This builder adds the raw code block. May require manual adjustment.</div>
             </div>
        </div>
        <!-- ----- END Skins/Camo Section ----- -->

    </div> <!-- End mainContent -->

</div> <!-- End container -->

<!-- Message Toast (Unchanged HTML Structure) -->
<div id="messageToast" class="message-toast">
    <span id="toastIcon" class="toast-icon">✓</span>
    <span id="toastText">Success!</span>
</div>

<script>
    // Global variables (Unchanged)
    let PAYLOAD = {};
    const builders = {};
    let rndSeed = Math.floor(1000 + Math.random() * 9000);
    let apiCallTimer;
    let rebuildTimer;
    let lastGeneratedOutput = '';
    let isManualEditMode = false;
    let messageTimeout;
    let currentBaseInputString = ''; // Store the applied base input

    // --- DOM Elements Cache (Unchanged) ---
    const dom = {
        body: document.body,
        messageArea: document.getElementById('message-area'),
        itemTypeSel: document.getElementById('itemTypeSel'),
        raritySel: document.getElementById('raritySel'),
        outWrapper: document.getElementById('out'),
        outCode: document.querySelector('#out code'),
        baseSerial: document.getElementById('baseSerial'),
        serial_b85: document.getElementById('serial_b85'),
        additionalData: document.getElementById('additionalData'),
        copyFull: document.getElementById('copyFull'),
        copySerial: document.getElementById('copySerial'),
        dice: document.getElementById('dice'),
        copyFullStatus: document.getElementById('copyFullStatus'),
        copyApiStatus: document.getElementById('copyApiStatus'),
        undoEditBtn: document.getElementById('undoEdit'),
        reserializeManualBtn: document.getElementById('reserializeManual'),
        applyInputBtn: document.getElementById('applyInputBtn'),
        deserializeBtn: document.getElementById('deserializeBtn'),
        messageToast: document.getElementById('messageToast'),
        toastIcon: document.getElementById('toastIcon'),
        toastText: document.getElementById('toastText')
    };

    // --- Utility Functions (Unchanged) ---
    function showMessage(text, type = 'info', duration = 3000) {
        if (!dom.messageToast || !dom.toastIcon || !dom.toastText) {
            console.warn("Toast elements not found, using fallback message area.");
            const oldMessageArea = document.getElementById('message-area');
            if (oldMessageArea) {
                oldMessageArea.innerHTML = text.replace(/<code>(.*?)<\/code>/g, '$1');
                oldMessageArea.className = `message-area visible ${type === 'success' ? 'success' : type === 'error' ? 'error' : ''}`;
                oldMessageArea.style.display = 'block';
                if (type !== 'error') {
                    clearTimeout(oldMessageArea.timer);
                    oldMessageArea.timer = setTimeout(() => {
                        oldMessageArea.style.display = 'none';
                        oldMessageArea.classList.remove('visible');
                    }, duration);
                }
            }
            return;
        }
        clearTimeout(messageTimeout);
        dom.toastIcon.textContent = type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️';
        dom.toastText.innerHTML = text; // Use innerHTML to render code tags if present
        dom.messageToast.className = `message-toast ${type} show`;
        messageTimeout = setTimeout(() => {
            dom.messageToast.classList.remove('show');
        }, duration);
    }
    function showCopyStatus(statusElement, message) {
        if (!statusElement) return;
        statusElement.textContent = message;
        statusElement.classList.add('visible');
        clearTimeout(statusElement.timer);
        statusElement.timer = setTimeout(() => {
            statusElement.classList.remove('visible');
        }, 1500);
    }

    // --- Collapsible Section Logic (Unchanged) ---
    function setupCollapsibleSections() {
        const collapsibleCards = document.querySelectorAll('.card.collapsible');
        collapsibleCards.forEach(card => {
            const header = card.querySelector('h2') || card.querySelector('.row.titleRow');
            const content = card.querySelector('.collapsible-content');
            if (!header || !content) {
                console.warn('Collapsible structure incorrect:', card);
                return;
            }
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'toggle-btn';
            toggleBtn.setAttribute('aria-expanded', 'false');
            toggleBtn.title = 'Toggle Section';
            // Insert button appropriately within the header flex container
            if (header.tagName === 'H2') {
                header.appendChild(toggleBtn); // Append if it's a simple H2
            } else if (header.classList.contains('titleRow')) {
                 // Insert before the filter row if it exists
                 const filterRow = header.querySelector('.filterRow');
                 if (filterRow) {
                     header.insertBefore(toggleBtn, filterRow);
                 } else {
                     header.appendChild(toggleBtn);
                 }
            }

            toggleBtn.addEventListener('click', () => {
                const isExpanded = content.classList.toggle('expanded');
                toggleBtn.classList.toggle('expanded', isExpanded);
                toggleBtn.setAttribute('aria-expanded', isExpanded);
            });
        });
    }

    // --- Generic Builder UI Logic ---
    function createBuilder(key, nameField, codeField, idPrefix) {
        const dataList = PAYLOAD[key] || [];
        const filterInput = document.getElementById(`filter${idPrefix}`);
        const availList = document.getElementById(`avail${idPrefix}`);
        const selList = document.getElementById(`sel${idPrefix}`);
        const addBtn = document.getElementById(`add${idPrefix}`);
        const remBtn = document.getElementById(`rem${idPrefix}`);
        const clearBtn = document.getElementById(`clear${idPrefix}`);

        if (!filterInput || !availList || !selList || !addBtn || !remBtn || !clearBtn) {
            throw new Error(`Missing DOM elements for builder ${idPrefix}`);
        }

        let selectedItems = [];
        const codeToNameMap = {};

        if (!Array.isArray(dataList)) {
            throw new Error(`Expected array for key ${key}`);
        }

        dataList.forEach(item => {
            const code = item[codeField];
            if (code === undefined || code === null) return;
            const name = item[nameField] || 'Unnamed Item';
            const variant = item.variant ? ` "${item.variant}"` : '';
            const group = item.group ? ` (${item.group})` : '';
            codeToNameMap[code] = `${name}${variant}${group}`;
        });

        function populateAvailable() {
            const fragment = document.createDocumentFragment();
            const query = (filterInput.value || '').toLowerCase();
            availList.innerHTML = '';

            let processedList = (dataList || [])
                .filter(item => {
                    const code = item[codeField];
                    if (code === undefined || code === null) return false;
                    const name = codeToNameMap[code] || '';
                    // Use actual code format in search text
                    const searchText = `${name} ${code}`.toLowerCase(); // Check name and code block
                    return !query || searchText.includes(query);
                });

            // --- MODIFICATION START: Custom Sorting Logic ---
            if (key !== 'weaponSkins' && key !== 'weaponElements') {
                 processedList.sort((a, b) => {
                     const codeA = a[codeField];
                     const codeB = b[codeField];
                     const nameA = codeToNameMap[codeA] || '';
                     const nameB = codeToNameMap[codeB] || '';

                     // Specifically for legendary perks: Move "Color Spray" to bottom
                     if (key === 'legendaryPerks') {
                         const aIsColorSpray = nameA.startsWith("Color Spray");
                         const bIsColorSpray = nameB.startsWith("Color Spray");

                         if (aIsColorSpray && !bIsColorSpray) return 1; // Move A down
                         if (!aIsColorSpray && bIsColorSpray) return -1; // Move B down
                         // If both are Color Spray or neither is, sort alphabetically
                     }
                     // Default alphabetical sort for all other applicable cases
                     return nameA.localeCompare(nameB);
                 });
             }
             // --- MODIFICATION END ---

             processedList.forEach(item => {
                const code = item[codeField];
                const displayName = codeToNameMap[code];
                const o = document.createElement('option');
                o.value = code; // Value is the code block string
                o.textContent = `${displayName} ${code}`; // Display name and code block
                fragment.appendChild(o);
             });

            availList.appendChild(fragment);
        }

        function renderSelected() {
            const scrollState = { top: selList.scrollTop, left: selList.scrollLeft };
            const selectedValues = new Set(Array.from(selList.selectedOptions).map(opt => opt.value)); // Preserve selection based on code value
            selList.innerHTML = '';
            selectedItems.forEach((code, index) => {
                const name = codeToNameMap[code] || 'Unknown Code';
                const o = document.createElement('option');
                o.value = code; // Value is the code block string
                o.textContent = `${name} ${code}`; // Display name and code block
                o.dataset.index = index; // Store original index for removal
                if (selectedValues.has(code)) { // Re-select if it was selected
                    o.selected = true;
                }
                selList.appendChild(o);
            });
             selList.scrollTop = scrollState.top;
             selList.scrollLeft = scrollState.left;
             if (!isManualEditMode) {
                 triggerDebouncedRebuild();
             }
        }

        function addSelected() {
            Array.from(availList.selectedOptions).forEach(opt => selectedItems.push(opt.value));
            renderSelected();
        }

        function removeSelected() {
            const indicesToRemoveInView = Array.from(selList.selectedOptions)
                                            .map(opt => parseInt(opt.dataset.index, 10))
                                            .filter(index => !isNaN(index));

            if (indicesToRemoveInView.length === 0) return;

            // Sort indices in descending order to avoid shifting issues
            indicesToRemoveInView.sort((a, b) => b - a);

            // Remove items by index
            indicesToRemoveInView.forEach(index => {
                if (index >= 0 && index < selectedItems.length) {
                    selectedItems.splice(index, 1);
                }
            });

            renderSelected();
        }


        function clearSelected() {
            selectedItems = [];
            renderSelected();
        }

        populateAvailable();
        filterInput.addEventListener('input', populateAvailable);
        addBtn.addEventListener('click', addSelected);
        remBtn.addEventListener('click', removeSelected);
        clearBtn.addEventListener('click', clearSelected);
        selList.addEventListener('keydown', e => { if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); removeSelected(); } });
        selList.addEventListener('dblclick', removeSelected);
        availList.addEventListener('dblclick', addSelected);

        return { getSelectedItems: () => selectedItems, clear: clearSelected };
    }

    // --- Condensing Logic (Unchanged) ---
    function getPartId(code) { const match = code.match(/\{(\d+)/); return match ? match[1] : null; }
    function condenseParts(parts) {
         if (!parts || parts.length === 0) return [];
         const grouped = {};
         const individualParts = []; // For parts not matching standard formats or added manually
         const finalCondensed = [];

         parts.forEach(code => {
             if (typeof code !== 'string' || !code.trim()) return; // Skip invalid entries
             const trimmedCode = code.trim();
             // Regex handles spaces around ':', within '[]', and optional values
             const match = trimmedCode.match(/^\s*\{(\d+)(?:\s*:\s*([^}\[\]]+)|\s*:\s*\[([^\]]+)\])?\s*\}\s*$/);
             if (match) {
                 const id = match[1];
                 const value = match[2]?.trim(); // Single value
                 const arrayValuesStr = match[3]?.trim(); // Values inside brackets
                 const valuesFromArray = arrayValuesStr ? arrayValuesStr.split(/\s+/).filter(v => v) : [];

                 if (!grouped[id]) grouped[id] = { simple: 0, values: new Set() };

                 if (value) {
                     grouped[id].values.add(value);
                 } else if (valuesFromArray.length > 0) {
                     valuesFromArray.forEach(v => grouped[id].values.add(v));
                 } else {
                     grouped[id].simple++;
                 }
             } else if (!trimmedCode.includes('||')) {
                  individualParts.push(trimmedCode);
             }
         });

         // Process grouped parts
         for (const id in grouped) {
              const group = grouped[id];
              const hasValues = group.values.size > 0;
              const hasSimple = group.simple > 0;

              if (hasValues) {
                   const sortedValues = Array.from(group.values).sort(); // Sort for consistency
                   finalCondensed.push(`{${id}:[${sortedValues.join(' ')}]}`);
              }
              // Add simple {ID} only if it existed AND (EITHER no values existed OR values also existed)
              if (hasSimple && (!hasValues || hasValues)) {
                   finalCondensed.push(`{${id}}`);
              }
         }

         return [...finalCondensed, ...individualParts]; // Combine and return
     }


    // --- Output Rebuilding (Unchanged) ---
    function rebuildOutput() {
        try {
            // Use the current random seed, don't regenerate here unless dice is clicked
            const currentSeed = rndSeed;

            const baseInput = currentBaseInputString; // Read from global var
            let baseHeader = '';
            let baseDynamicParts = []; // Parts parsed FROM the base input string

            // 1. Parse Base Input
            if (baseInput) {
                 const headerMatch = baseInput.match(/^([^\{]*\|\|\s*)/);
                 if (headerMatch) {
                     // Extract header, ensure seed is correct
                     const headerContent = headerMatch[0].trim();
                     const parts = headerContent.split('||')[0].split('|');
                     if (parts.length === 2) {
                         const firstPart = parts[0].trim();
                         const secondPartParts = parts[1].trim().split(',');
                         if (secondPartParts.length === 2) baseHeader = `${firstPart}| ${secondPartParts[0].trim()}, ${currentSeed}||`; // Update seed
                         else baseHeader = headerContent; // Malformed, keep original
                     } else baseHeader = headerContent; // Malformed, keep original

                     const remaining = baseInput.substring(headerMatch[0].length).trim();
                     baseDynamicParts = remaining ? remaining.split(/\s+/).filter(p => p.length > 0 && p !== '|') : [];
                 } else {
                      // Attempt to parse non-standard header + parts
                     const firstBlockIndex = baseInput.indexOf('{');
                     if (firstBlockIndex === 0) { // No header found, treat all as parts
                          baseHeader = '';
                          baseDynamicParts = baseInput.split(/\s+/).filter(p => p.length > 0 && p !== '|');
                     } else if (firstBlockIndex > 0) { // Assume text before first { is header
                         baseHeader = baseInput.substring(0, firstBlockIndex).trim();
                          // Try to update seed in simple header format
                          const simpleHeaderParts = baseHeader.split('|');
                          if (simpleHeaderParts.length === 2) {
                              const firstPart = simpleHeaderParts[0].trim();
                              const secondPartParts = simpleHeaderParts[1].trim().split(',');
                               if (secondPartParts.length === 2) baseHeader = `${firstPart}| ${secondPartParts[0].trim()}, ${currentSeed}`; // Update seed
                          }
                         baseDynamicParts = baseInput.substring(firstBlockIndex).trim().split(/\s+/).filter(p => p.length > 0 && p !== '|');
                     } else { // No parts found, treat all as header
                          baseHeader = baseInput.replace(/\|$/, '').trim(); // Remove trailing pipe if present
                          baseDynamicParts = [];
                     }
                }
            } else {
                // Generate Base Header if no input provided
                const typeMap = { gun: 1, shield: 2, grenade: 3, classmod: 4, enhancement: 5 };
                const itemTypeId = typeMap[dom.itemTypeSel.value] || 0;
                 baseHeader = `${itemTypeId}, 0, 1, 50| 2, ${currentSeed}||`;
                 // Rarity part added as a dynamic part if no base input
                 const rarityCodeMap = { common: 217, uncommon: 218, rare: 219, epic: 220, legendary: 999 }; // Example map
                 const rarityPart = `{${rarityCodeMap[dom.raritySel.value] || 0}}`;
                 if (rarityPart !== '{0}') baseDynamicParts.push(rarityPart); // Only add if rarity is valid
            }

            // 2. Collect parts from ALL builders
            const builderPartsRaw = [];
            Object.values(builders).forEach(builder => {
                if (typeof builder.getSelectedItems === 'function') {
                    builderPartsRaw.push(...builder.getSelectedItems());
                }
            });
            const builderPartsSet = new Set(builderPartsRaw); // Use Set for efficient lookup

            // 3. Combine and Condense ALL dynamic parts (base + builder)
            const allPartsToCondense = [...baseDynamicParts, ...builderPartsRaw];
            const condensedParts = condenseParts(allPartsToCondense); // Note: condenseParts returns the string representation {ID} or {ID:V} or {ID:[A B]}

            // 4. Build Output HTML, highlighting builder parts
            let outputHtml = '';
            if (baseHeader) {
                outputHtml += baseHeader; // Add header first
            }

            condensedParts.forEach((partStr, index) => {
                let isAdded = false;
                 // Check if this condensed part originated from a builder part
                 const arrayMatch = partStr.match(/^\{(\d+):\s*\[([^\]]+)\]\s*\}$/);
                 if (arrayMatch) {
                     // If it's an array block, check if ANY of its constituent values came from builders
                     const id = arrayMatch[1];
                     const values = arrayMatch[2].trim().split(/\s+/);
                     isAdded = values.some(val => builderPartsSet.has(`{${id}:${val}}`));
                     // Also check if a simple {ID} part contributed (less common for arrays)
                     if (!isAdded) isAdded = builderPartsSet.has(`{${id}}`);
                 } else {
                     // If it's a simple {ID} or {ID:Value}, check directly
                     isAdded = builderPartsSet.has(partStr);
                 }

                // Add space before part if needed
                if ((baseHeader || index > 0) && outputHtml.length > 0 && !outputHtml.endsWith(' ')) {
                     outputHtml += ' ';
                }

                // Append part, wrapped if it was added
                if (isAdded) {
                    outputHtml += `<span class="added-part">${partStr}</span>`;
                } else {
                    outputHtml += partStr;
                }
            });

            // 5. Add final pipe correctly
            let finalOutputString = outputHtml.replace(/<[^>]*>/g, ''); // Get text version for logic check
            if ((baseHeader || condensedParts.length > 0) && !finalOutputString.endsWith('|')) {
                 outputHtml += '|'; // Add trailing pipe if parts exist after header and pipe isn't already there
            }
             // Cleanup potential multiple spaces (do this on the HTML string carefully)
             outputHtml = outputHtml.replace(/\s{2,}/g, ' ').replace(/ <span/g, '<span').replace(/span> /g, 'span>'); // Clean spaces around spans

            lastGeneratedOutput = outputHtml.replace(/<[^>]*>/g, ''); // Store plain text version

            // Update output display using innerHTML if not manually editing
            if (document.activeElement !== dom.outCode) {
                 dom.outCode.innerHTML = outputHtml; // Set HTML content
                 // If we rebuild automatically, turn off manual edit mode
                 if (isManualEditMode) {
                     isManualEditMode = false;
                     dom.outCode.classList.remove('manual-edit');
                     dom.outWrapper.classList.remove('manual-edit');
                     dom.outWrapper.querySelector('.manual-edit-indicator').style.display = 'none';
                 }
            }
             // Ensure message area is hidden unless an error occurs later
             if (dom.messageArea.style.display !== 'none' && !dom.messageArea.classList.contains('error')) {
                 dom.messageArea.style.display = 'none';
             }

        } catch (err) {
            showMessage(`Error generating output: <code>${err.message}</code>. Check builder setup and data.`, 'error');
            console.error("Output Generation Error:", err);
            dom.outCode.textContent = '[Error generating output]'; // Use textContent for error
            lastGeneratedOutput = '';
        }
    }


     // --- Debounced Triggers and API Logic (Unchanged) ---
     const debounce = (func, wait) => { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), wait); }; };
     const debouncedRebuild = debounce(rebuildOutputAndCallApi, 50);
     const debouncedApiCall = debounce(callReserialize, 400);

     function triggerDebouncedRebuild() { if (!isManualEditMode) debouncedRebuild(); }
     function triggerDebouncedApiCall() { if (!isManualEditMode) debouncedApiCall(); }
     function rebuildOutputAndCallApi() { rebuildOutput(); triggerDebouncedApiCall(); }

    const API_BASE_URL = 'https://borderlands4-deserializer.nicnl.com/api/v1';

    // --- API Functions (Deserialize, Apply Input, Call Reserialize) - Unchanged ---
    async function deserializeSerial() {
        const input = dom.baseSerial.value.trim();
        if (!input) { showMessage('Please enter a serial code in the input box first.', 'error'); return; }
        if (!input.startsWith('@U')) { showMessage('Input does not look like a B85 serial (must start with @U). Cannot deserialize.', 'error'); return; }
        showMessage('Deserializing...', 'info', 2000);
        try {
            const serial = input;
            const response = await fetch(`${API_BASE_URL}/deserialize_bulk`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify([serial]) });
            if (!response.ok) { const errorText = await response.text(); throw new Error(`Deserialize request failed: ${response.status} - ${errorText}`); }
            const result = await response.json(); const firstKey = Object.keys(result)[0];
            if (result[firstKey] && result[firstKey].success !== false && result[firstKey].deserialized) {
                const deserialized = result[firstKey].deserialized; dom.baseSerial.value = deserialized;
                showMessage('✅ Deserialization successful! Now click "Apply Code Block" to continue.', 'success', 4000);
            } else { throw new Error(result[firstKey]?.error || 'Deserialization failed: API did not return expected data.'); }
        } catch (error) { console.error('Deserialize API Error:', error); showMessage('Deserialization failed: ' + error.message, 'error', 5000); }
    }

    function applyInput() {
        const input = dom.baseSerial.value.trim();
        if (!input) { showMessage('Input box is empty. Paste a deserialized string or deserialize a @U code first.', 'error'); return; }
        if (input.startsWith('@U')) { showMessage('⚠️ Input looks like a B85 serial! Please click "Deserialize Serial Code" first, then "Apply Code Block".', 'error', 5000); return; }
        // Looser check: accept if it contains at least one pipe '|'
        if (!input.includes('|')) { showMessage('⚠️ Invalid format! Expected deserialized format containing at least "|". Please check input or deserialize first.', 'error', 5000); return; }
        currentBaseInputString = input;
        // Clear all builder selections when applying new base input
         Object.values(builders).forEach(builder => { if (typeof builder.clear === 'function') builder.clear(); });
        showMessage('Input applied successfully. Builders cleared. Rebuilding...', 'success', 2500);
        rebuildOutputAndCallApi(); // Rebuild with cleared builders and trigger API
    }

    async function callReserialize() {
        if (dom.serial_b85) dom.serial_b85.textContent = 'Fetching...';
        if (dom.additionalData) dom.additionalData.textContent = '';
        dom.copySerial.disabled = true;
        try {
            const outText = (dom.outCode?.textContent || '').trim();
             const isValidSerial = outText.includes('||') && outText.endsWith('|');
             const isJustHeader = !outText.includes('{') && outText.includes('|') && !outText.endsWith('|') || outText.includes('||'); // Header only might lack parts/trailing pipe

             if (!outText || outText === '[Error generating output]' || (!isValidSerial && !isJustHeader)) {
                 if (dom.serial_b85) dom.serial_b85.textContent = '[No valid serial to send]';
                 // Don't show toast for this common case, just update status
                 return;
              }
            const resp = await fetch(`${API_BASE_URL}/reserialize`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ deserialized: outText }) });
            if (!resp.ok) { let errorText = `HTTP ${resp.status} - ${resp.statusText}`; try { const errorData = await resp.json(); errorText += `: ${errorData.error || errorData.message || 'Unknown API error'}`; } catch (_) {} throw new Error(errorText); }
            const data = await resp.json();
            if (dom.serial_b85) dom.serial_b85.textContent = data.serial_b85 || '[No serial returned]';
            if (dom.additionalData) dom.additionalData.textContent = data.additional_data || '[No details]';
            dom.copySerial.disabled = !data.serial_b85;
        } catch (err) {
            console.error('Reserialize API error:', err);
            if (dom.serial_b85) dom.serial_b85.textContent = `[API error: ${err.message}]`;
            if (dom.additionalData) dom.additionalData.textContent = '';
            dom.copySerial.disabled = true;
            if (!err.message.includes('aborted')) { showMessage(`API Error: ${err.message}`, 'error'); }
        }
    }

    // --- Initialization ---
    async function initializeApp() {
        currentBaseInputString = '';
        PAYLOAD = {}; // Reset payload on init

        try {
             // --- Fetch parts data with error handling ---
             try {
                const response = await fetch('bl4_parts_data.json'); // Attempt fetch
                if (!response.ok) throw new Error(`HTTP error ${response.status}`); // Check HTTP status
                PAYLOAD = await response.json(); // Attempt parse
                console.log("Successfully loaded bl4_parts_data.json");
            } catch (fetchError) {
                // Handle fetch or parse errors gracefully
                console.warn(`Could not load or parse bl4_parts_data.json: ${fetchError.message}. Builders relying on this data will be empty.`);
                showMessage(`Warning: Failed to load parts data (<code>bl4_parts_data.json</code>). Some builders will be empty. Error: ${fetchError.message}`, 'error', 8000);
                PAYLOAD = {}; // Ensure PAYLOAD is empty on failure so subsequent checks don't fail harder
            }

            // --- Validate REQUIRED keys (adjust based on essential builders) ---
            const requiredKeys = ['altFireModes', 'magazineModes', 'legendaryPerks', 'ordnancePerks', 'weaponElements', 'weaponSkins']; // Added weaponElements and weaponSkins
            const missingKeys = requiredKeys.filter(key => !PAYLOAD[key] || !Array.isArray(PAYLOAD[key]));

            // Only throw a fatal error if essential keys are missing *after* a successful load attempt
            if (missingKeys.length > 0 && Object.keys(PAYLOAD).length > 0) {
                 // Changed to warning instead of throwing error for more flexibility
                 console.warn(`Data Validation Warning: Key(s) <code>${missingKeys.join(', ')}</code> missing/invalid in loaded JSON.`);
                 // Optionally show a message to the user
                 // showMessage(`Warning: Parts data loaded but missing keys: ${missingKeys.join(', ')}. Some builders might be empty.`, 'error', 6000);
            }

            // --- Initialize Builders (This loop now gracefully skips builders if data is missing) ---
            document.querySelectorAll('.builderSection').forEach(section => {
                 const key = section.dataset.key;
                 const nameField = section.dataset.nameField;
                 const codeField = section.dataset.codeField;
                 const idPrefix = section.dataset.idPrefix;
                 // Check if the corresponding data exists in PAYLOAD before creating
                 if (key && nameField && codeField && idPrefix && PAYLOAD[key]) { // This check prevents errors if PAYLOAD is empty or key missing
                     try {
                         builders[key] = createBuilder(key, nameField, codeField, idPrefix);
                     } catch (builderError) {
                          // Log builder-specific errors but don't halt initialization
                          console.error(`Failed to init builder for ${key}: ${builderError.message}`);
                          showMessage(`Error initializing builder "${key}": ${builderError.message}`, 'error', 6000);
                     }
                 } else {
                     // Log which builders are skipped due to missing data (expected if fetch failed)
                     if (key && nameField && codeField && idPrefix) { // Only log if attributes are present but data is not
                        console.warn(`Skipping builder section "${key}", missing data in PAYLOAD.`);
                     } else {
                        console.warn("Skipping builder section, missing data-attributes:", section);
                     }
                 }
            });


            // --- Setup Event Listeners (Unchanged) ---
            dom.itemTypeSel.addEventListener('change', triggerDebouncedRebuild);
            dom.raritySel.addEventListener('change', triggerDebouncedRebuild);
            dom.dice.onclick = () => { rndSeed = Math.floor(1000 + Math.random()*9000); triggerDebouncedRebuild(); };
            dom.applyInputBtn.addEventListener('click', applyInput);
            dom.deserializeBtn.addEventListener('click', deserializeSerial);

            // Manual Edit Handling - Clear highlighting on input
            dom.outCode.addEventListener('input', () => {
                isManualEditMode = true;
                dom.outCode.classList.add('manual-edit');
                dom.outWrapper.classList.add('manual-edit');
                dom.outWrapper.querySelector('.manual-edit-indicator').style.display = 'inline';
                clearTimeout(apiCallTimer); // Stop automatic API calls
            });

            dom.undoEditBtn.addEventListener('click', () => {
                if (lastGeneratedOutput) {
                    isManualEditMode = false; // Turn off manual mode first
                    currentBaseInputString = lastGeneratedOutput; // Restore plain text
                    rebuildOutput(); // Rebuild to regenerate HTML highlighting
                    dom.outCode.classList.remove('manual-edit');
                    dom.outWrapper.classList.remove('manual-edit');
                    dom.outWrapper.querySelector('.manual-edit-indicator').style.display = 'none';
                    triggerDebouncedApiCall(); // Resume automatic API calls
                    showCopyStatus(dom.copyFullStatus, 'Edit Undone');
                } else {
                    showCopyStatus(dom.copyFullStatus, 'No history!');
                }
            });

            dom.reserializeManualBtn.addEventListener('click', callReserialize); // Allow manual API trigger

            // Copy Buttons (using clipboard API with fallback)
             dom.copyFull.addEventListener('click', async () => {
                 const text = (dom.outCode?.textContent || '').trim();
                 if (!text || text.startsWith('[')) return showMessage('No output to copy!', 'error');
                 try {
                     await navigator.clipboard.writeText(text);
                     showMessage('Output copied!', 'success');
                     showCopyStatus(dom.copyFullStatus, 'Copied!');
                 } catch(e) {
                      console.warn('Clipboard API failed, trying execCommand:', e);
                      // Fallback using execCommand
                      const textArea = document.createElement("textarea");
                      textArea.value = text;
                      textArea.style.position = "fixed"; textArea.style.left = "-9999px"; // Prevent scroll jump
                      document.body.appendChild(textArea);
                      textArea.select();
                      try { document.execCommand('copy'); showMessage('Output copied! (fallback)', 'success'); showCopyStatus(dom.copyFullStatus, 'Copied!'); }
                      catch (errFallback) { console.error('execCommand copy failed:', errFallback); showMessage('Copy failed!', 'error'); }
                      document.body.removeChild(textArea);
                 }
             });
             dom.copySerial.addEventListener('click', async () => {
                 const text = (dom.serial_b85?.textContent || '').trim();
                 if (!text || text.startsWith('[')) return showMessage('No API serial to copy!', 'error');
                 try {
                     await navigator.clipboard.writeText(text);
                     showMessage('API serial copied!', 'success');
                     showCopyStatus(dom.copyApiStatus, 'Copied!');
                 } catch(e) {
                      console.warn('Clipboard API failed, trying execCommand:', e);
                      // Fallback using execCommand
                      const textArea = document.createElement("textarea");
                      textArea.value = text;
                      textArea.style.position = "fixed"; textArea.style.left = "-9999px";
                      document.body.appendChild(textArea);
                      textArea.select();
                      try { document.execCommand('copy'); showMessage('API serial copied! (fallback)', 'success'); showCopyStatus(dom.copyApiStatus, 'Copied!'); }
                      catch (errFallback) { console.error('execCommand copy failed:', errFallback); showMessage('Copy failed!', 'error'); }
                      document.body.removeChild(textArea);
                 }
             });


             setupCollapsibleSections(); // Unchanged call
             rebuildOutput(); // Initial build
             setTimeout(callReserialize, 150); // Initial API call
        } catch (error) {
             // Catch critical errors during initialization (e.g., failed essential data load)
            showMessage(`Critical Initialization failed: ${error.message}`, 'error', 10000);
            console.error("Critical Initialization error:", error);
            // Disable interactions if critical init fails
             document.querySelectorAll('input, select, button, [contenteditable]').forEach(el => { if(el) el.disabled = true; });
             if (dom.baseSerial) dom.baseSerial.disabled = true;
             if (dom.outCode) dom.outCode.contentEditable = false;
        }
    }
    // --- DOM Ready ---
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp(); // DOM was already ready
    }
</script>
</body>
</html>

