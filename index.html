<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport"/>
    <title>BL4 Weapon Part Editor (Hosted)</title>
    <style>
        /* Base styles adapted from Enhancement_Editor.html */
        :root { --bg:#0b0f14; --card:#0e1520; --ink:#e6f0ff; --muted:#a6b4c8; --line:#1f2a3a; --accent-orange: #e59400; --danger-red: #e74c3c; --success-green: #28a745; --edit-yellow: #ffc107; --preview-bg: rgba(0, 0, 0, 0.3); --preview-border: rgba(102, 126, 234, 0.4); --preview-accent: #667eea; }
        * { box-sizing: border-box; }
        body { font-family: 'Inter', system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--bg); color: var(--ink); padding: 0; font-size: 16px; line-height: 1.5; margin: 0; }

        /* --- TAB NAVIGATION STYLES --- */
        .tab-nav { background-color: var(--card); border-bottom: 1px solid var(--line); padding: 0 18px; margin-bottom: 18px; display: flex; gap: 10px; }
        .tab-link { display: inline-block; padding: 12px 16px; color: var(--muted); text-decoration: none; border-bottom: 3px solid transparent; transition: color 0.2s ease, border-color 0.2s ease; font-weight: 500; font-size: 15px; }
        .tab-link:hover { color: var(--ink); }
        .tab-link.active { color: var(--accent-orange); border-bottom-color: var(--accent-orange); }
        /* --- END TAB STYLES --- */

        .container { max-width: 1200px; margin: 0 auto; padding: 0 18px 18px 18px; }
        h2 { margin: 0 0 14px; border-bottom: 1px solid var(--line); padding-bottom: 8px; font-weight: 700; display: flex; justify-content: space-between; align-items: center; }
        .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
        .card { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 14px 16px; display: flex; flex-direction: column; margin-bottom: 14px; }
        label { color: var(--muted); font-size: 12px; display: block; margin-bottom: 6px; font-weight: 400; }
        select, input, button, textarea { background: #0f1720; color: var(--ink); border: 1px solid var(--line); border-radius: 10px; padding: 10px 12px; font-size: 16px; font-family: inherit; }
        input::placeholder, textarea::placeholder { color: var(--muted); opacity: 0.7; }
        select[multiple] { padding: 4px; }
        select:focus, input:focus, button:focus, textarea:focus { outline: 2px solid var(--accent-orange); outline-offset: 1px; border-color: var(--accent-orange); }
        code { background:#0c121b; border: 1px solid var(--line); padding: 4px 8px; display: inline-block; border-radius: 6px; font-size: 0.9em; font-family: monospace; }
        button { cursor: pointer; background-color: #2c2c4d; transition: background-color 0.2s ease; margin-right: 5px; }
        button:last-of-type { margin-right: 0; }
        button:hover { background-color: #4b4b7d; }
        button:disabled { background-color: #2c2c4d; opacity: 0.5; cursor: not-allowed; }
        button.small { padding: 6px 10px; border-radius: 8px; font-size: 14px; min-height: 38px; min-width: 38px; }
        .wrap { white-space: normal; word-break: break-word; }
        #baseSerial { width: 100%; min-height: 80px; margin-top: 6px; font-family: monospace; font-size: 0.9em; resize: vertical; }
        .input-button-group { margin-top: 10px; }

        /* --- COLLAPSIBLE STYLES --- */
        .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; margin-top: 0; }
        .collapsible-content.expanded { max-height: 1000px; margin-top: 14px; }
        .toggle-btn { background: none; border: none; color: var(--muted); font-size: 1.5em; line-height: 1; padding: 0 5px; cursor: pointer; opacity: 0.7; transition: opacity 0.2s, color 0.2s; margin-left: 10px; }
        .toggle-btn:hover { opacity: 1; }
        .toggle-btn::before { content: '[+]'; color: var(--success-green); }
        .toggle-btn.expanded::before { content: '[-]'; color: var(--danger-red); }
        .builderSection .row.titleRow { justify-content: space-between; align-items: center; padding-bottom: 8px; margin-bottom: 0; border-bottom: 1px solid var(--line); }
        .builderSection .row.titleRow > div:first-child { font-weight: 700; color: var(--muted); font-size: 1.1em; border-bottom: none; padding-bottom: 0; margin-bottom: 0; flex-grow: 1; }
        .builderSection .row.filterRow { flex-grow: 0; flex-shrink: 0; width: auto; }
        /* --- END COLLAPSIBLE STYLES --- */

        /* Builder Styles */
        .builderSection .row.selects { margin-top: 8px; display: flex; gap: 10px; align-items: stretch; }
        .builderSection select { flex: 1; min-height: 220px; width: 100%; border-radius: 8px;}
        .builderSection .buttons { display: flex; flex-direction: column; gap: 8px; justify-content: center; width: 56px; align-items: center; }
        .builderSection .tip { margin-top: 10px; font-size: 12px; color: var(--muted); }

        /* Output Card Styles */
        .outCard code { display: block; overflow: auto; width: 100%; white-space: pre-wrap; word-break: break-all; max-height: 100px; min-height: 50px; background: #0c121b; padding: 10px; border-radius: 8px; border: 2px solid var(--line); transition: border-color 0.3s ease; }
        .outCard code[contenteditable="plaintext-only"] { outline: none; }
        .outCard code[contenteditable="plaintext-only"]:focus { border-color: var(--edit-yellow); }
        .outCard code.manual-edit { border-color: var(--edit-yellow); }
        #apiCard code { max-height: 100px; }
        .sticky { position: sticky; top: 0; z-index: 20; background: var(--bg); }
        #message-area { padding: 10px 18px; margin-bottom: 14px; border-radius: 8px; font-size: 14px; display: none; border: 1px solid transparent; }
        #message-area.visible { display: block; }
        #message-area.error { background-color: rgba(231, 76, 60, 0.2); border-color: var(--danger-red); color: var(--danger-red); }
        #message-area.success { background-color: rgba(40, 167, 69, 0.2); border-color: var(--success-green); color: var(--success-green); }
        .copy-status { font-size: 12px; color: var(--muted); margin-left: 5px; opacity: 0; transition: opacity 0.3s ease; }
        .copy-status.visible { opacity: 1; }
        .manual-edit-indicator { display: none; font-size: 11px; color: var(--edit-yellow); margin-left: 8px; }
        .outCard.manual-edit .manual-edit-indicator { display: inline; }

        #serial_b85 { display: block; overflow: auto; max-height: 100px; white-space: pre-wrap; word-break: break-all; }
        .added-part { color: var(--success-green); font-weight: 500; }

        /* Message Toast Styles */
        .message-toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); display: none; align-items: center; gap: 10px; z-index: 10000; opacity: 0; transition: opacity 0.3s ease, bottom 0.3s ease; font-size: 15px; }
        .message-toast.show { display: flex; opacity: 1; bottom: 30px; }
        .message-toast.success { background: rgba(40, 167, 69, 0.9); border: 1px solid var(--success-green); color: #fff; }
        .message-toast.error { background: rgba(231, 76, 60, 0.9); border: 1px solid var(--danger-red); color: #fff; }
        .message-toast.info { background: rgba(44, 44, 77, 0.95); border: 1px solid var(--line); color: var(--ink); }
        .toast-icon { font-size: 1.2em; line-height: 1; }
        /* --- END Message Toast Styles --- */

        /* --- Live Preview Styles --- */
        .live-preview { background: var(--preview-bg); border-radius: 15px; padding: 20px; margin-bottom: 20px; border: 1px solid var(--preview-border); position: relative; display: none; /* Hidden by default */ }
        .live-preview.visible { display: block; }
        .item-info { display: flex; align-items: center; gap: 15px; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--line); }
        .item-icon { font-size: 3em; }
        .item-details h3 { font-size: 1.3em; margin-bottom: 5px; color: #ffd700; }
        .item-details p { font-size: 0.9em; opacity: 0.8; margin: 2px 0; }
        .preview-label { font-weight: bold; font-size: 0.9em; opacity: 0.7; margin-bottom: 5px; color: var(--muted); }
        .preview-serial { background: rgba(0, 0, 0, 0.4); padding: 10px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.85em; word-wrap: break-word; color: #4ade80; line-height: 1.6; max-height: 150px; overflow-y: auto; }
        .modifications-summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 10px; }
        .mod-badge { background: rgba(102, 126, 234, 0.2); border: 1px solid var(--preview-accent); padding: 8px 12px; border-radius: 8px; text-align: center; font-size: 0.85em; position: relative; }
        .mod-badge strong { display: block; color: #ffd700; font-size: 1.2em; margin-bottom: 3px; }
        .mod-badge-list { margin-top: 8px; max-height: 150px; overflow-y: auto; text-align: left; padding-right: 5px; } /* Added padding for scrollbar */
        .mod-badge-item { padding: 5px 8px; margin: 4px 0; background: rgba(255, 255, 255, 0.05); border-radius: 5px; display: flex; justify-content: space-between; align-items: center; font-size: 0.9em; }
        .mod-badge-item .remove-btn { cursor: pointer; color: #ff6b6b; font-weight: bold; padding: 0px 6px; border-radius: 3px; transition: background 0.2s ease; margin-left: 5px; font-size: 1.1em; line-height: 1; }
        .mod-badge-item .remove-btn:hover { background: rgba(255, 107, 107, 0.2); }
        /* --- END Live Preview Styles --- */


        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .tab-nav { padding: 0 10px; margin-bottom: 10px; }
            .tab-link { padding: 10px 8px; font-size: 14px; }
            .container { padding: 0 10px 10px 10px; }
            .outCard code { max-height: 120px; }
            .outCard .row { flex-wrap: wrap; }
            .outCard .row button.small { min-height: 30px; }
            #dice { padding: 4px 8px !important; font-size: 12px !important; }
            .builderSection .row.titleRow { flex-wrap: wrap; }
            .builderSection .row.filterRow { width: 100%; justify-content: space-between; margin-top: 5px;}
            .message-toast { width: calc(100% - 40px); left: 20px; transform: none; }
            .item-info { flex-direction: column; align-items: flex-start; }
            .modifications-summary { grid-template-columns: 1fr; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; height: 8px;}
        ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.2); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #4b4b7d 0%, var(--preview-accent) 100%); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: linear-gradient(135deg, var(--preview-accent) 0%, #4b4b7d 100%); }
    </style>
</head>
<body>

    <!-- TAB NAVIGATION BAR (Unchanged) -->
    <nav class="tab-nav">
        <a href="Deseralizer Comparator.html" class="tab-link">Comparator & Editor</a>
        <a href="Deseralizer Comparator.html#deserializer" class="tab-link">Deserializer</a>
        <a href="bl4_decoder.html" class="tab-link active">Workstation</a>
    </nav>

<div class="container">
    <div id="message-area"></div> <!-- Kept as fallback -->

    <h2>BL4 Weapon Part Editor (Workstation)</h2>

    <!-- Input Serial Section (Unchanged) -->
    <div class="card" id="inputCard">
        <label for="baseSerial">Input Base Serial String (@U or Deserialized)</label>
        <textarea id="baseSerial" rows="3" placeholder="Paste @U... serial (click Deserialize first) OR deserialized format like: 9, 0, 1, 50| 2, 1626|| {80} {2}|"></textarea>
        <div class="input-button-group">
            <button id="applyInputBtn">Apply Code Block & Identify Parts</button> <!-- Renamed Button -->
            <button id="deserializeBtn">Deserialize Serial Code</button>
        </div>
        <p style="margin-top: 10px; opacity: 0.8; font-size: 0.9em; color: var(--muted);">
            If pasting a <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">@U...</code> serial, click "Deserialize" first, then "Apply Code Block".
        </p>
    </div>
    <!-- END Input Serial Section -->

    <!-- ***** NEW: Live Preview Panel ***** -->
    <div id="livePreview" class="live-preview"> <!-- Initially hidden via style, made visible by JS -->
        <div class="item-info">
            <div id="itemIcon" class="item-icon">❓</div>
            <div class="item-details">
                <h3 id="itemName">[No Item Loaded]</h3>
                <p id="itemType">Type: Unknown</p>
                <p id="itemManufacturer">Manufacturer: Unknown</p>
                <p id="itemRarity" style="font-weight: bold;">Rarity: Unknown</p>
            </div>
        </div>
        <div class="preview-label">📋 Base Serial (Modifiable by removing parts below):</div>
        <div class="preview-serial" id="liveSerialPreview">Load a serial using "Apply Code Block" above...</div>
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--line);">
            <div class="preview-label" style="margin-bottom: 8px;">🔍 Identified Parts (Click ✕ to remove from Base Serial):</div>
            <div class="modifications-summary" id="modsSummary">
                <em style="opacity: 0.5; grid-column: 1 / -1;">No parts identified yet.</em>
            </div>
        </div>
    </div>
    <!-- ***** END Live Preview Panel ***** -->


    <!-- Output + API (Sticky) (Unchanged) -->
    <div class="card outCard sticky">
        <div class="row" style="justify-content: space-between; align-items: center;">
            <div style="color:var(--muted)">Output Serial String <span class="manual-edit-indicator">(Manual Edit Mode)</span></div>
            <div class="row">
                 <button class="small" id="reserializeManual" title="Reserialize Manual Edit">🔄 API</button>
                 <button class="small" id="undoEdit" title="Undo Manual Edit & Rebuild">↩️ Undo</button>
                 <button class="small" id="copyFull" title="Copy Output String">📋</button>
                 <span id="copyFullStatus" class="copy-status"></span>
            </div>
        </div>
        <div id="out" style="margin-top:6px"><code contenteditable="plaintext-only"><!-- Output code will appear here --></code></div>
         <button class="small" id="dice" title="New random seed" style="margin-top: 10px; width: fit-content;">🎲 New Seed</button>
    </div>

     <div class="card" id="apiCard" style="margin-bottom:14px">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
            <div>
                <div style="color:var(--muted)">Validated Serial (API Result)</div>
                <div id="serialWrap" style="margin-top:6px"><code id="serial_b85"><!-- API Serial B85 --></code></div>
                <div id="addDataWrap" style="margin-top:6px;color:var(--muted); font-size: 12px;">
                    <span style="opacity:.8">Details (API):</span> <code id="additionalData" style="font-size: 12px;"><!-- API Additional Data --></code>
                </div>
            </div>
            <div class="row" style="gap:8px">
                <button class="small" id="copySerial" title="Copy API Serial" disabled>📋</button>
                <span id="copyApiStatus" class="copy-status"></span>
            </div>
        </div>
    </div>

     <div id="mainContent">
        <!-- Base Item Card (Unchanged) -->
        <div class="card collapsible" id="baseItemCard">
             <h2>Base Item Properties (Builder Input Only)</h2>
             <div class="collapsible-content">
                 <div class="row">
                    <div style="flex: 1;">
                        <label>Base Item Type (Placeholder for Header)</label>
                        <select id="itemTypeSel">
                            <option value="gun">Generic Gun</option>
                            <option value="shield">Shield</option>
                            <option value="grenade">Grenade Mod</option>
                            <option value="classmod">Class Mod</option>
                            <option value="enhancement">Enhancement</option>
                        </select>
                    </div>
                     <div style="flex: 1;">
                        <label>Rarity (Placeholder for Header)</label>
                        <select id="raritySel">
                            <option value="common">Common</option>
                            <option value="uncommon">Uncommon</option>
                            <option value="rare">Rare</option>
                            <option value="epic">Epic</option>
                            <option value="legendary">Legendary</option>
                        </select>
                    </div>
                 </div>
                 <p class="tip" style="margin-top: 10px;">Note: Item Type/Rarity are primarily determined by the loaded serial's data (shown in preview). These selectors mainly influence the header if no serial is loaded.</p>
             </div>
        </div>
        <!-- Legendary Perks (Unchanged) -->
        <div class="card builderSection collapsible" data-key="legendaryPerks" data-name-field="name" data-code-field="code" data-id-prefix="LegPerk">
             <div class="row titleRow">
                 <div>Legendary Perk Part Variations (Add New)</div>
                 <div class="row filterRow">
                    <input id="filterLegPerk" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearLegPerk" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availLegPerk" multiple size="8" aria-label="Available Legendary Perks"></select>
                    <div class="buttons">
                        <button id="addLegPerk" title="Add Selected">»</button>
                        <button id="remLegPerk" title="Remove Selected">«</button>
                    </div>
                    <select id="selLegPerk" multiple size="8" aria-label="Selected Legendary Perks"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Adds parts to the base serial.</div>
             </div>
        </div>
        <!-- Alt Fire Modes (Unchanged) -->
        <div class="card builderSection collapsible" data-key="altFireModes" data-name-field="name" data-code-field="code" data-id-prefix="AltFire">
            <div class="row titleRow">
                <div>Alt Fire Mode Variations (Add New)</div>
                <div class="row filterRow">
                    <input id="filterAltFire" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearAltFire" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availAltFire" multiple size="8" aria-label="Available Alt Fire Modes"></select>
                    <div class="buttons">
                        <button id="addAltFire" title="Add Selected">»</button>
                        <button id="remAltFire" title="Remove Selected">«</button>
                    </div>
                    <select id="selAltFire" multiple size="8" aria-label="Selected Alt Fire Modes"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Adds parts to the base serial.</div>
            </div>
        </div>
        <!-- Magazine Modes (Unchanged) -->
        <div class="card builderSection collapsible" data-key="magazineModes" data-name-field="name" data-code-field="code" data-id-prefix="MagMode">
             <div class="row titleRow">
                <div>Magazine / Ammo Mode Variations (Add New)</div>
                 <div class="row filterRow">
                    <input id="filterMagMode" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearMagMode" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availMagMode" multiple size="8" aria-label="Available Magazine/Ammo Modes"></select>
                    <div class="buttons">
                        <button id="addMagMode" title="Add Selected">»</button>
                        <button id="remMagMode" title="Remove Selected">«</button>
                    </div>
                    <select id="selMagMode" multiple size="8" aria-label="Selected Magazine/Ammo Modes"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Adds parts to the base serial.</div>
             </div>
        </div>

        <!-- ----- Elements Section (Unchanged) ----- -->
        <div class="card builderSection collapsible" data-key="weaponElements" data-name-field="name" data-code-field="code" data-id-prefix="Elem">
             <div class="row titleRow">
                 <div>Elements (Add New)</div>
                 <div class="row filterRow">
                    <input id="filterElem" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearElem" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availElem" multiple size="8" aria-label="Available Elements"></select>
                    <div class="buttons">
                        <button id="addElem" title="Add Selected">»</button>
                        <button id="remElem" title="Remove Selected">«</button>
                    </div>
                    <select id="selElem" multiple size="8" aria-label="Selected Elements"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Adds parts to the base serial.</div>
             </div>
        </div>
        <!-- ----- END Elements Section ----- -->

        <!-- Ordnance Perks (Unchanged) -->
        <div class="card builderSection collapsible" data-key="ordnancePerks" data-name-field="name" data-code-field="code" data-id-prefix="OrdPerk">
             <div class="row titleRow">
                <div>Ordnance Legendary Perks (Add New)</div>
                 <div class="row filterRow">
                    <input id="filterOrdPerk" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearOrdPerk" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availOrdPerk" multiple size="8" aria-label="Available Ordnance Perks"></select>
                    <div class="buttons">
                        <button id="addOrdPerk" title="Add Selected">»</button>
                        <button id="remOrdPerk" title="Remove Selected">«</button>
                    </div>
                    <select id="selOrdPerk" multiple size="8" aria-label="Selected Ordnance Perks"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Adds parts to the base serial.</div>
             </div>
        </div>

        <!-- ----- Skins/Camo Section (Unchanged) ----- -->
        <div class="card builderSection collapsible" data-key="weaponSkins" data-name-field="name" data-code-field="code" data-id-prefix="Skin">
             <div class="row titleRow">
                 <div>Skins / Camo (Add New)</div>
                 <div class="row filterRow">
                    <input id="filterSkin" placeholder="Filter..." type="text"/>
                    <button class="small" id="clearSkin" title="Clear Selected">❌</button>
                </div>
            </div>
             <div class="collapsible-content">
                <div class="row selects">
                    <select id="availSkin" multiple size="8" aria-label="Available Weapon Skins"></select>
                    <div class="buttons">
                        <button id="addSkin" title="Add Selected">»</button>
                        <button id="remSkin" title="Remove Selected">«</button>
                    </div>
                    <select id="selSkin" multiple size="8" aria-label="Selected Weapon Skins"></select>
                </div>
                 <div class="tip">Double-click to add/remove. Adds parts to the base serial.</div>
             </div>
        </div>
        <!-- ----- END Skins/Camo Section ----- -->

    </div> <!-- End mainContent -->

</div> <!-- End container -->

<!-- Message Toast (Unchanged HTML Structure) -->
<div id="messageToast" class="message-toast">
    <span id="toastIcon" class="toast-icon">✓</span>
    <span id="toastText">Success!</span>
</div>

<script>
    // Global variables
    let PAYLOAD = {}; // Holds data from bl4_parts_data.json
    const builders = {}; // Holds references to the dual-listbox builders
    let rndSeed = Math.floor(1000 + Math.random() * 9000); // Default seed
    let apiCallTimer; // For debouncing API calls
    let rebuildTimer; // For debouncing output rebuilds
    let lastGeneratedOutput = ''; // Stores last known good output for Undo
    let isManualEditMode = false; // Flag for manual edits in output
    let messageTimeout; // Timer for hiding messages
    let currentBaseInputString = ''; // Stores the applied base input (can be modified by part removal)

    // --- NEW: Reverse Lookup Maps ---
    const partCodeToNameMaps = {
        legendaryPerks: {},
        altFireModes: {},
        magazineModes: {},
        weaponElements: {},
        ordnancePerks: {},
        weaponSkins: {}
        // Add other categories here if needed for identification
    };
    let dataLoaded = false; // Flag to check if PAYLOAD is populated

    // --- DOM Elements Cache ---
    const dom = {
        body: document.body,
        messageArea: document.getElementById('message-area'),
        itemTypeSel: document.getElementById('itemTypeSel'),
        raritySel: document.getElementById('raritySel'),
        outWrapper: document.getElementById('out'),
        outCode: document.querySelector('#out code'),
        baseSerial: document.getElementById('baseSerial'),
        serial_b85: document.getElementById('serial_b85'),
        additionalData: document.getElementById('additionalData'),
        copyFull: document.getElementById('copyFull'),
        copySerial: document.getElementById('copySerial'),
        dice: document.getElementById('dice'),
        copyFullStatus: document.getElementById('copyFullStatus'),
        copyApiStatus: document.getElementById('copyApiStatus'),
        undoEditBtn: document.getElementById('undoEdit'),
        reserializeManualBtn: document.getElementById('reserializeManual'),
        applyInputBtn: document.getElementById('applyInputBtn'),
        deserializeBtn: document.getElementById('deserializeBtn'),
        messageToast: document.getElementById('messageToast'),
        toastIcon: document.getElementById('toastIcon'),
        toastText: document.getElementById('toastText'),
        // --- NEW: Live Preview Elements ---
        livePreview: document.getElementById('livePreview'),
        liveSerialPreview: document.getElementById('liveSerialPreview'),
        modsSummary: document.getElementById('modsSummary'),
        itemIcon: document.getElementById('itemIcon'),
        itemName: document.getElementById('itemName'),
        itemType: document.getElementById('itemType'),
        itemManufacturer: document.getElementById('itemManufacturer'),
        itemRarity: document.getElementById('itemRarity')
    };

    // --- Utility Functions (Unchanged) ---
    function showMessage(text, type = 'info', duration = 3000) {
        // ... (implementation remains the same)
        if (!dom.messageToast || !dom.toastIcon || !dom.toastText) { console.warn("Toast elements not found..."); return; }
        clearTimeout(messageTimeout);
        dom.toastIcon.textContent = type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️';
        dom.toastText.innerHTML = text;
        dom.messageToast.className = `message-toast ${type} show`;
        messageTimeout = setTimeout(() => { dom.messageToast.classList.remove('show'); }, duration);
    }
    function showCopyStatus(statusElement, message) {
        // ... (implementation remains the same)
        if (!statusElement) return; statusElement.textContent = message; statusElement.classList.add('visible'); clearTimeout(statusElement.timer); statusElement.timer = setTimeout(() => { statusElement.classList.remove('visible'); }, 1500);
    }

    // --- Collapsible Section Logic (Unchanged) ---
    function setupCollapsibleSections() {
        // ... (implementation remains the same)
        document.querySelectorAll('.card.collapsible').forEach(card => {
            const header = card.querySelector('h2') || card.querySelector('.row.titleRow');
            const content = card.querySelector('.collapsible-content');
            if (!header || !content) { console.warn('Collapsible structure incorrect:', card); return; }
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'toggle-btn'; toggleBtn.setAttribute('aria-expanded', 'false'); toggleBtn.title = 'Toggle Section';
            if (header.tagName === 'H2') { header.appendChild(toggleBtn); }
            else if (header.classList.contains('titleRow')) {
                 const filterRow = header.querySelector('.filterRow');
                 if (filterRow) { header.insertBefore(toggleBtn, filterRow); }
                 else { header.appendChild(toggleBtn); }
            }
            toggleBtn.addEventListener('click', () => { const isExpanded = content.classList.toggle('expanded'); toggleBtn.classList.toggle('expanded', isExpanded); toggleBtn.setAttribute('aria-expanded', isExpanded); });
        });
    }

    // --- Generic Builder UI Logic (Unchanged except for sorting) ---
    function createBuilder(key, nameField, codeField, idPrefix) {
        // ... (implementation mostly the same)
        const dataList = PAYLOAD[key] || [];
        const filterInput = document.getElementById(`filter${idPrefix}`);
        const availList = document.getElementById(`avail${idPrefix}`);
        const selList = document.getElementById(`sel${idPrefix}`);
        const addBtn = document.getElementById(`add${idPrefix}`);
        const remBtn = document.getElementById(`rem${idPrefix}`);
        const clearBtn = document.getElementById(`clear${idPrefix}`);
        if (!filterInput || !availList || !selList || !addBtn || !remBtn || !clearBtn) { throw new Error(`Missing DOM elements for builder ${idPrefix}`); }
        let selectedItems = [];
        const codeToNameMap = {}; // Local map for this builder instance
        if (!Array.isArray(dataList)) { throw new Error(`Expected array for key ${key}`); }
        dataList.forEach(item => { const code = item[codeField]; if (code === undefined || code === null) return; const name = item[nameField] || 'Unnamed Item'; const variant = item.variant ? ` "${item.variant}"` : ''; const group = item.group ? ` (${item.group})` : ''; codeToNameMap[code] = `${name}${variant}${group}`; });

        function populateAvailable() {
            const fragment = document.createDocumentFragment();
            const query = (filterInput.value || '').toLowerCase();
            availList.innerHTML = '';
            let processedList = (dataList || [])
                .filter(item => { const code = item[codeField]; if (code === undefined || code === null) return false; const name = codeToNameMap[code] || ''; const searchText = `${name} ${code}`.toLowerCase(); return !query || searchText.includes(query); });

            // --- Sorting Logic (Same as previous correct version) ---
            if (key !== 'weaponSkins' && key !== 'weaponElements') {
                 processedList.sort((a, b) => {
                     const codeA = a[codeField]; const codeB = b[codeField]; const nameA = codeToNameMap[codeA] || ''; const nameB = codeToNameMap[codeB] || '';
                     if (key === 'legendaryPerks') { const aIsColorSpray = nameA.startsWith("Color Spray"); const bIsColorSpray = nameB.startsWith("Color Spray"); if (aIsColorSpray && !bIsColorSpray) return 1; if (!aIsColorSpray && bIsColorSpray) return -1; }
                     return nameA.localeCompare(nameB);
                 });
             }
             // --- END Sorting Logic ---

             processedList.forEach(item => { const code = item[codeField]; const displayName = codeToNameMap[code]; const o = document.createElement('option'); o.value = code; o.textContent = `${displayName} ${code}`; fragment.appendChild(o); });
            availList.appendChild(fragment);
        }
        function renderSelected() { /* ... (implementation unchanged) ... */ const scrollState={top:selList.scrollTop, left:selList.scrollLeft}; const selectedValues=new Set(Array.from(selList.selectedOptions).map(opt=>opt.value)); selList.innerHTML=''; selectedItems.forEach((code,index)=>{const name=codeToNameMap[code]||'Unknown Code'; const o=document.createElement('option'); o.value=code; o.textContent=`${name} ${code}`; o.dataset.index=index; if(selectedValues.has(code)){o.selected=true;} selList.appendChild(o);}); selList.scrollTop=scrollState.top; selList.scrollLeft=scrollState.left; if(!isManualEditMode){triggerDebouncedRebuild();} }
        function addSelected() { /* ... (implementation unchanged) ... */ Array.from(availList.selectedOptions).forEach(opt => selectedItems.push(opt.value)); renderSelected(); }
        function removeSelected() { /* ... (implementation unchanged) ... */ const indicesToRemoveInView=Array.from(selList.selectedOptions).map(opt=>parseInt(opt.dataset.index,10)).filter(index=>!isNaN(index)); if(indicesToRemoveInView.length===0)return; indicesToRemoveInView.sort((a,b)=>b-a); indicesToRemoveInView.forEach(index=>{if(index>=0&&index<selectedItems.length){selectedItems.splice(index,1);}}); renderSelected(); }
        function clearSelected() { /* ... (implementation unchanged) ... */ selectedItems = []; renderSelected(); }
        populateAvailable(); filterInput.addEventListener('input', populateAvailable); addBtn.addEventListener('click', addSelected); remBtn.addEventListener('click', removeSelected); clearBtn.addEventListener('click', clearSelected); selList.addEventListener('keydown', e => { if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); removeSelected(); } }); selList.addEventListener('dblclick', removeSelected); availList.addEventListener('dblclick', addSelected);
        return { getSelectedItems: () => selectedItems, clear: clearSelected };
    }

    // --- Condensing Logic (Unchanged) ---
    function getPartId(code) { /* ... */ const match = code.match(/\{(\d+)/); return match ? match[1] : null; }
    function condenseParts(parts) { /* ... (implementation unchanged) ... */ if(!parts||parts.length===0)return[]; const grouped={}; const individualParts=[]; const finalCondensed=[]; parts.forEach(code=>{if(typeof code!=='string'||!code.trim())return; const trimmedCode=code.trim(); const match=trimmedCode.match(/^\s*\{(\d+)(?:\s*:\s*([^}\[\]]+)|\s*:\s*\[([^\]]+)\])?\s*\}\s*$/); if(match){const id=match[1]; const value=match[2]?.trim(); const arrayValuesStr=match[3]?.trim(); const valuesFromArray=arrayValuesStr?arrayValuesStr.split(/\s+/).filter(v=>v):[]; if(!grouped[id])grouped[id]={simple:0,values:new Set()}; if(value){grouped[id].values.add(value);}else if(valuesFromArray.length>0){valuesFromArray.forEach(v=>grouped[id].values.add(v));}else{grouped[id].simple++;}}else if(!trimmedCode.includes('||')){individualParts.push(trimmedCode);}}); for(const id in grouped){const group=grouped[id]; const hasValues=group.values.size>0; const hasSimple=group.simple>0; if(hasValues){const sortedValues=Array.from(group.values).sort(); finalCondensed.push(`{${id}:[${sortedValues.join(' ')}]}`);} if(hasSimple&&(!hasValues||hasValues)){finalCondensed.push(`{${id}}`);}} return[...finalCondensed,...individualParts]; }

    // --- Output Rebuilding (Unchanged) ---
    function rebuildOutput() {
        // ... (implementation remains the same, combines currentBaseInputString + builder parts)
        try { const currentSeed = rndSeed; const baseInput = currentBaseInputString; let baseHeader = ''; let baseDynamicParts = []; if (baseInput) { const headerMatch = baseInput.match(/^([^\{]*\|\|\s*)/); if (headerMatch) { const headerContent = headerMatch[0].trim(); const parts = headerContent.split('||')[0].split('|'); if (parts.length === 2) { const firstPart = parts[0].trim(); const secondPartParts = parts[1].trim().split(','); if (secondPartParts.length === 2) baseHeader = `${firstPart}| ${secondPartParts[0].trim()}, ${currentSeed}||`; else baseHeader = headerContent; } else baseHeader = headerContent; const remaining = baseInput.substring(headerMatch[0].length).trim(); baseDynamicParts = remaining ? remaining.split(/\s+/).filter(p => p.length > 0 && p !== '|') : []; } else { const firstBlockIndex = baseInput.indexOf('{'); if (firstBlockIndex === 0) { baseHeader = ''; baseDynamicParts = baseInput.split(/\s+/).filter(p => p.length > 0 && p !== '|'); } else if (firstBlockIndex > 0) { baseHeader = baseInput.substring(0, firstBlockIndex).trim(); const simpleHeaderParts = baseHeader.split('|'); if (simpleHeaderParts.length === 2) { const firstPart = simpleHeaderParts[0].trim(); const secondPartParts = simpleHeaderParts[1].trim().split(','); if (secondPartParts.length === 2) baseHeader = `${firstPart}| ${secondPartParts[0].trim()}, ${currentSeed}`; } baseDynamicParts = baseInput.substring(firstBlockIndex).trim().split(/\s+/).filter(p => p.length > 0 && p !== '|'); } else { baseHeader = baseInput.replace(/\|$/, '').trim(); baseDynamicParts = []; } } } else { const typeMap = { gun: 1, shield: 2, grenade: 3, classmod: 4, enhancement: 5 }; const itemTypeId = typeMap[dom.itemTypeSel.value] || 0; baseHeader = `${itemTypeId}, 0, 1, 50| 2, ${currentSeed}||`; const rarityCodeMap = { common: 217, uncommon: 218, rare: 219, epic: 220, legendary: 999 }; const rarityPart = `{${rarityCodeMap[dom.raritySel.value] || 0}}`; if (rarityPart !== '{0}') baseDynamicParts.push(rarityPart); } const builderPartsRaw = []; Object.values(builders).forEach(builder => { if (typeof builder.getSelectedItems === 'function') { builderPartsRaw.push(...builder.getSelectedItems()); } }); const builderPartsSet = new Set(builderPartsRaw); const allPartsToCondense = [...baseDynamicParts, ...builderPartsRaw]; const condensedParts = condenseParts(allPartsToCondense); let outputHtml = ''; if (baseHeader) { outputHtml += baseHeader; } condensedParts.forEach((partStr, index) => { let isAdded = false; const arrayMatch = partStr.match(/^\{(\d+):\s*\[([^\]]+)\]\s*\}$/); if (arrayMatch) { const id = arrayMatch[1]; const values = arrayMatch[2].trim().split(/\s+/); isAdded = values.some(val => builderPartsSet.has(`{${id}:${val}}`)); if (!isAdded) isAdded = builderPartsSet.has(`{${id}}`); } else { isAdded = builderPartsSet.has(partStr); } if ((baseHeader || index > 0) && outputHtml.length > 0 && !outputHtml.endsWith(' ')) { outputHtml += ' '; } if (isAdded) { outputHtml += `<span class="added-part">${partStr}</span>`; } else { outputHtml += partStr; } }); let finalOutputString = outputHtml.replace(/<[^>]*>/g, ''); if ((baseHeader || condensedParts.length > 0) && !finalOutputString.endsWith('|')) { outputHtml += '|'; } outputHtml = outputHtml.replace(/\s{2,}/g, ' ').replace(/ <span/g, '<span').replace(/span> /g, 'span>'); lastGeneratedOutput = outputHtml.replace(/<[^>]*>/g, ''); if (document.activeElement !== dom.outCode) { dom.outCode.innerHTML = outputHtml; if (isManualEditMode) { isManualEditMode = false; dom.outCode.classList.remove('manual-edit'); dom.outWrapper.classList.remove('manual-edit'); dom.outWrapper.querySelector('.manual-edit-indicator').style.display = 'none'; } } if (dom.messageArea.style.display !== 'none' && !dom.messageArea.classList.contains('error')) { dom.messageArea.style.display = 'none'; } } catch (err) { showMessage(`Error generating output: <code>${err.message}</code>. Check builder setup and data.`, 'error'); console.error("Output Generation Error:", err); dom.outCode.textContent = '[Error generating output]'; lastGeneratedOutput = ''; }
    }


     // --- Debounced Triggers and API Logic (Unchanged) ---
     const debounce = (func, wait) => { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), wait); }; };
     const debouncedRebuild = debounce(rebuildOutputAndCallApi, 50);
     const debouncedApiCall = debounce(callReserialize, 400);

     function triggerDebouncedRebuild() { if (!isManualEditMode) debouncedRebuild(); }
     function triggerDebouncedApiCall() { if (!isManualEditMode) debouncedApiCall(); }
     function rebuildOutputAndCallApi() { rebuildOutput(); triggerDebouncedApiCall(); }

    const API_BASE_URL = 'https://borderlands4-deserializer.nicnl.com/api/v1';

    // --- API Functions (Deserialize, Call Reserialize) - Unchanged ---
    async function deserializeSerial() { /* ... (implementation unchanged) ... */ const input=dom.baseSerial.value.trim(); if(!input){showMessage('Please enter a serial code...','error');return;} if(!input.startsWith('@U')){showMessage('Input does not look like a B85 serial...','error');return;} showMessage('Deserializing...','info',2000); try{const serial=input; const response=await fetch(`${API_BASE_URL}/deserialize_bulk`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify([serial])}); if(!response.ok){const errorText=await response.text();throw new Error(`Deserialize failed: ${response.status} - ${errorText}`);} const result=await response.json(); const firstKey=Object.keys(result)[0]; if(result[firstKey]&&result[firstKey].success!==false&&result[firstKey].deserialized){const deserialized=result[firstKey].deserialized; dom.baseSerial.value=deserialized; showMessage('✅ Deserialized! Click "Apply Code Block..." to continue.','success',4000);}else{throw new Error(result[firstKey]?.error||'Deserialization failed...');}}catch(error){console.error('Deserialize API Error:',error); showMessage('Deserialization failed: '+error.message,'error',5000);} }
    async function callReserialize() {
        // ... (implementation unchanged, but now also updates live preview metadata)
        if (dom.serial_b85) dom.serial_b85.textContent = 'Fetching...';
        if (dom.additionalData) dom.additionalData.textContent = '';
        dom.copySerial.disabled = true;
        try {
            const outText = (dom.outCode?.textContent || '').trim();
            const isValidSerial = outText.includes('||') && outText.endsWith('|');
            const isJustHeader = !outText.includes('{') && (outText.includes('|') || outText.includes('||'));
             if (!outText || outText === '[Error generating output]' || (!isValidSerial && !isJustHeader)) {
                 if (dom.serial_b85) dom.serial_b85.textContent = '[No valid serial to send]'; return;
             }
            const resp = await fetch(`${API_BASE_URL}/reserialize`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ deserialized: outText }) });
            if (!resp.ok) { let errorText = `HTTP ${resp.status} - ${resp.statusText}`; try { const errorData = await resp.json(); errorText += `: ${errorData.error || errorData.message || 'Unknown API error'}`; } catch (_) {} throw new Error(errorText); }
            const data = await resp.json();
            if (dom.serial_b85) dom.serial_b85.textContent = data.serial_b85 || '[No serial returned]';
            if (dom.additionalData) dom.additionalData.textContent = data.additional_data || '[No details]';
            dom.copySerial.disabled = !data.serial_b85;

            // --- NEW: Update Live Preview Metadata ---
            updateLivePreviewMetadata(data.additional_data);

        } catch (err) { /* ... (error handling unchanged) ... */ console.error('Reserialize API error:', err); if (dom.serial_b85) dom.serial_b85.textContent = `[API error: ${err.message}]`; if (dom.additionalData) dom.additionalData.textContent = ''; dom.copySerial.disabled = true; if (!err.message.includes('aborted')) { showMessage(`API Error: ${err.message}`, 'error'); } }
    }

    // --- NEW: Part Identification and Display Logic ---
    function buildReverseLookupMaps() {
        if (!PAYLOAD || Object.keys(PAYLOAD).length === 0) {
            console.warn("Cannot build lookup maps: PAYLOAD is empty.");
            return;
        }
        for (const key in partCodeToNameMaps) {
            if (PAYLOAD[key] && Array.isArray(PAYLOAD[key])) {
                PAYLOAD[key].forEach(item => {
                    if (item.code && item.name) {
                        partCodeToNameMaps[key][item.code] = item.name;
                    }
                });
            } else {
                 console.warn(`Data for key "${key}" not found or invalid in PAYLOAD.`);
            }
        }
        console.log("Built reverse lookup maps:", partCodeToNameMaps);
    }

    function findPartName(code) {
        for (const key in partCodeToNameMaps) {
            if (partCodeToNameMaps[key][code]) {
                return { name: partCodeToNameMaps[key][code], type: key };
            }
        }
        return { name: 'Unknown Part', type: 'unknown' };
    }

    function identifyAndDisplayParts(serialString) {
        if (!dataLoaded) {
            showMessage("Parts data not loaded yet, cannot identify parts.", "error");
            return;
        }
        if (!serialString) {
             dom.modsSummary.innerHTML = '<em style="opacity: 0.5;">Load a serial first.</em>';
             dom.livePreview.classList.remove('visible'); // Hide if no serial
             return;
        }

        const identifiedParts = {
            legendaryPerks: [],
            altFireModes: [],
            magazineModes: [],
            weaponElements: [],
            ordnancePerks: [],
            weaponSkins: []
            // Add other categories if needed
        };
        const unknownParts = [];

        // Simple parsing: extract header, then split remaining parts
        let partsString = serialString;
        const headerMatch = serialString.match(/^([^\{]*\|\|\s*)/);
        if (headerMatch) {
            partsString = serialString.substring(headerMatch[0].length);
        } else {
             // Handle simpler headers if needed, or assume parts start after first pipe if no ||
             const firstPipe = serialString.indexOf('|');
             if (firstPipe !== -1 && !serialString.includes('||')) {
                  partsString = serialString.substring(firstPipe + 1);
             }
        }

        const codes = partsString.replace(/\|+$/, '').trim().match(/\{[^\}]+\}/g) || [];

        codes.forEach(code => {
            const { name, type } = findPartName(code);
            if (type !== 'unknown' && identifiedParts[type]) {
                identifiedParts[type].push({ name, code });
            } else {
                unknownParts.push(code); // Keep track if needed
            }
        });

        // --- Render Identified Parts in Live Preview ---
        dom.modsSummary.innerHTML = ''; // Clear previous
        let foundParts = false;

        Object.entries(identifiedParts).forEach(([type, partsList]) => {
            if (partsList.length > 0) {
                foundParts = true;
                const badgeDiv = document.createElement('div');
                badgeDiv.className = 'mod-badge';
                // Simple title based on type key
                let title = type.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                if(type === 'legendaryPerks') title = 'Legendary Perks';
                if(type === 'altFireModes') title = 'Alt-Fire';
                if(type === 'magazineModes') title = 'Magazine';
                if(type === 'weaponElements') title = 'Element';
                if(type === 'ordnancePerks') title = 'Ordnance Perks';
                if(type === 'weaponSkins') title = 'Skin/Camo';

                badgeDiv.innerHTML = `<strong>${partsList.length}</strong> ${title}`;
                const listDiv = document.createElement('div');
                listDiv.className = 'mod-badge-list';
                partsList.forEach(part => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'mod-badge-item';
                    itemDiv.innerHTML = `<span>${part.name} <code style="font-size: 0.9em; opacity: 0.7;">${part.code}</code></span>`;
                    const removeBtn = document.createElement('span');
                    removeBtn.className = 'remove-btn';
                    removeBtn.innerHTML = '✕';
                    removeBtn.title = `Remove ${part.name}`;
                    // Use closure to capture correct part info for the event listener
                    removeBtn.onclick = (e) => {
                        e.stopPropagation(); // Prevent potential parent clicks
                        removeIdentifiedPart(type, part.code, itemDiv); // Pass element for potential visual feedback
                    };
                    itemDiv.appendChild(removeBtn);
                    listDiv.appendChild(itemDiv);
                });
                badgeDiv.appendChild(listDiv);
                dom.modsSummary.appendChild(badgeDiv);
            }
        });

        if (!foundParts && unknownParts.length === 0) {
             dom.modsSummary.innerHTML = '<em style="opacity: 0.5;">No known parts identified in the base serial.</em>';
        } else if (!foundParts && unknownParts.length > 0) {
             dom.modsSummary.innerHTML = `<em style="opacity: 0.5;">No known parts identified. Found unknown codes: ${unknownParts.join(' ')}</em>`;
        }
        // Update the live preview serial display as well
        dom.liveSerialPreview.textContent = currentBaseInputString || 'Load a serial first...';
        // Make preview visible
        dom.livePreview.classList.add('visible');
    }

     // --- NEW: Remove Identified Part Logic ---
     function removeIdentifiedPart(type, codeToRemove, elementToRemove) {
         console.log(`Attempting to remove ${type} part: ${codeToRemove}`);
         if (!currentBaseInputString) return;

         // Use regex to remove the specific code block, handling potential surrounding spaces
         // Escape special characters in the code for the regex
         const escapedCode = codeToRemove.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
         const regex = new RegExp(`\\s*${escapedCode}\\s*`, 'g');

         const originalLength = currentBaseInputString.length;
         currentBaseInputString = currentBaseInputString.replace(regex, ' ').trim(); // Replace with space, then trim ends
         currentBaseInputString = currentBaseInputString.replace(/\s{2,}/g, ' '); // Collapse multiple spaces

         if (currentBaseInputString.length < originalLength) {
             showMessage(`Removed ${codeToRemove}`, 'success', 1500);

             // Re-identify and display parts based on the modified string
             identifyAndDisplayParts(currentBaseInputString);

             // Trigger a rebuild of the main output area
             rebuildOutputAndCallApi(); // Use combined function

             // Optional: visual feedback like removing the element directly
             // if (elementToRemove) elementToRemove.remove();
         } else {
             showMessage(`Could not find ${codeToRemove} in the base serial to remove.`, 'error');
             console.warn(`Failed to remove ${codeToRemove} from: ${currentBaseInputString}`);
         }
     }


     // --- NEW: Update Live Preview Metadata ---
     function updateLivePreviewMetadata(additionalDataString) {
         let name = '[Unknown Name]', type = 'Unknown', mfg = 'Unknown', rarity = '';

         if (additionalDataString && additionalDataString !== '[No details]') {
             // Basic parsing, can be refined
             const nameMatch = additionalDataString.match(/"([^"]+)"/);
             if (nameMatch) name = nameMatch[1];

             const typeMatch = additionalDataString.match(/L\d+\s+([\w-]+):/i);
             if (typeMatch) type = typeMatch[1].charAt(0).toUpperCase() + typeMatch[1].slice(1);

             const mfgMatch = additionalDataString.match(/:(\w+)/);
             if (mfgMatch) mfg = mfgMatch[1].charAt(0).toUpperCase() + mfgMatch[1].slice(1);

             if (additionalDataString.toLowerCase().includes('legendary')) rarity = 'Legendary';
             else if (additionalDataString.toLowerCase().includes('epic')) rarity = 'Epic';
             else if (additionalDataString.toLowerCase().includes('rare')) rarity = 'Rare';
             else if (additionalDataString.toLowerCase().includes('uncommon')) rarity = 'Uncommon';
             else if (additionalDataString.toLowerCase().includes('common')) rarity = 'Common';
         }

         dom.itemName.textContent = name;
         dom.itemType.textContent = `Type: ${type}`;
         dom.itemManufacturer.textContent = `Manufacturer: ${mfg}`;
         dom.itemRarity.textContent = `Rarity: ${rarity}`;
         dom.itemRarity.style.color = rarity === 'Legendary' ? 'var(--accent-orange)' : rarity === 'Epic' ? '#a335ee' : rarity === 'Rare' ? '#0070dd' : rarity === 'Uncommon' ? 'var(--success-green)' : 'var(--muted)';

         // Update Icon based on type (simple example)
          const icons = { 'Sniper': '🎯', 'Shotgun': '💥', 'Pistol': '🔫', 'Smg': '⚡', 'Assault-rifle': ' बंदूक', 'Heavy': '🚀' }; // Added Heavy
          dom.itemIcon.textContent = icons[type] || '❓';

     }

     function getItemIcon(type) { // Helper retained if needed elsewhere, but logic moved to updateLivePreviewMetadata
            const icons = { 'Sniper': '🎯', 'Shotgun': '💥', 'Pistol': '🔫', 'Smg': '⚡', 'Assault-rifle': ' बंदूक', 'Heavy': '🚀' };
            return icons[type] || '❓';
     }


    // --- Apply Input (Modified) ---
    function applyInput() {
        const input = dom.baseSerial.value.trim();
        if (!input) { showMessage('Input box is empty...', 'error'); return; }
        if (input.startsWith('@U')) { showMessage('⚠️ Input looks like B85! Deserialize first, then Apply.', 'error', 5000); return; }
        if (!input.includes('|')) { showMessage('⚠️ Invalid format! Expected deserialized format...', 'error', 5000); return; }

        currentBaseInputString = input; // Store the raw input

        // Clear all builder selections when applying new base input
         Object.values(builders).forEach(builder => { if (typeof builder.clear === 'function') builder.clear(); });

        showMessage('Input applied. Identifying parts...', 'success', 2500);

        // --- NEW: Identify and Display Parts ---
        identifyAndDisplayParts(currentBaseInputString);

        // Rebuild output (based on new base + cleared builders) and trigger API
        rebuildOutputAndCallApi();
    }


    // --- Initialization (Modified) ---
    async function initializeApp() {
        currentBaseInputString = '';
        PAYLOAD = {}; // Reset payload
        dataLoaded = false; // Reset data loaded flag

        try {
             // Fetch parts data with error handling (Unchanged)
             try {
                const response = await fetch('bl4_parts_data.json');
                if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                PAYLOAD = await response.json();
                console.log("Successfully loaded bl4_parts_data.json");
                dataLoaded = true; // Set flag
                buildReverseLookupMaps(); // --- NEW: Build maps after loading ---
            } catch (fetchError) { /* ... (error handling unchanged) ... */ console.warn(`Could not load bl4_parts_data.json: ${fetchError.message}.`); showMessage(`Warning: Failed to load parts data... Error: ${fetchError.message}`, 'error', 8000); PAYLOAD={}; }

            // Validate REQUIRED keys (Unchanged)
            const requiredKeys = ['altFireModes', 'magazineModes', 'legendaryPerks', 'ordnancePerks', 'weaponElements', 'weaponSkins'];
            const missingKeys = requiredKeys.filter(key => !PAYLOAD[key] || !Array.isArray(PAYLOAD[key]));
            if (missingKeys.length > 0 && dataLoaded) { console.warn(`Data Validation Warning: Key(s) ${missingKeys.join(', ')} missing/invalid.`); }

            // Initialize Builders (Unchanged)
            document.querySelectorAll('.builderSection').forEach(section => {
                 const key = section.dataset.key; const nameField = section.dataset.nameField; const codeField = section.dataset.codeField; const idPrefix = section.dataset.idPrefix;
                 if (key && nameField && codeField && idPrefix && PAYLOAD[key]) {
                     try { builders[key] = createBuilder(key, nameField, codeField, idPrefix); }
                     catch (builderError) { console.error(`Failed to init builder for ${key}: ${builderError.message}`); showMessage(`Error initializing builder "${key}"`, 'error', 6000); }
                 } else { if (key && nameField && codeField && idPrefix) { console.warn(`Skipping builder "${key}", missing data.`); } else { console.warn("Skipping builder, missing data-attributes:", section); } }
            });

            // Setup Event Listeners (Unchanged)
            dom.itemTypeSel.addEventListener('change', triggerDebouncedRebuild);
            dom.raritySel.addEventListener('change', triggerDebouncedRebuild);
            dom.dice.onclick = () => { rndSeed = Math.floor(1000 + Math.random()*9000); triggerDebouncedRebuild(); };
            dom.applyInputBtn.addEventListener('click', applyInput);
            dom.deserializeBtn.addEventListener('click', deserializeSerial);
            dom.outCode.addEventListener('input', () => { isManualEditMode = true; dom.outCode.classList.add('manual-edit'); dom.outWrapper.classList.add('manual-edit'); dom.outWrapper.querySelector('.manual-edit-indicator').style.display = 'inline'; clearTimeout(apiCallTimer); });
            dom.undoEditBtn.addEventListener('click', () => { if (lastGeneratedOutput) { isManualEditMode = false; currentBaseInputString = lastGeneratedOutput; identifyAndDisplayParts(currentBaseInputString); /* <-- Refresh preview on undo */ rebuildOutput(); dom.outCode.classList.remove('manual-edit'); dom.outWrapper.classList.remove('manual-edit'); dom.outWrapper.querySelector('.manual-edit-indicator').style.display = 'none'; triggerDebouncedApiCall(); showCopyStatus(dom.copyFullStatus, 'Edit Undone'); } else { showCopyStatus(dom.copyFullStatus, 'No history!'); } });
            dom.reserializeManualBtn.addEventListener('click', callReserialize);
            dom.copyFull.addEventListener('click', async () => { /* ... (clipboard logic unchanged) ... */ const text = (dom.outCode?.textContent || '').trim(); if (!text || text.startsWith('[')) return showMessage('No output to copy!', 'error'); try { await navigator.clipboard.writeText(text); showMessage('Output copied!', 'success'); showCopyStatus(dom.copyFullStatus, 'Copied!'); } catch(e) { console.warn('Clipboard API failed, trying execCommand:', e); const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = "fixed"; textArea.style.left = "-9999px"; document.body.appendChild(textArea); textArea.select(); try { document.execCommand('copy'); showMessage('Output copied! (fallback)', 'success'); showCopyStatus(dom.copyFullStatus, 'Copied!'); } catch (errFallback) { console.error('execCommand copy failed:', errFallback); showMessage('Copy failed!', 'error'); } document.body.removeChild(textArea); } });
            dom.copySerial.addEventListener('click', async () => { /* ... (clipboard logic unchanged) ... */ const text = (dom.serial_b85?.textContent || '').trim(); if (!text || text.startsWith('[')) return showMessage('No API serial to copy!', 'error'); try { await navigator.clipboard.writeText(text); showMessage('API serial copied!', 'success'); showCopyStatus(dom.copyApiStatus, 'Copied!'); } catch(e) { console.warn('Clipboard API failed, trying execCommand:', e); const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = "fixed"; textArea.style.left = "-9999px"; document.body.appendChild(textArea); textArea.select(); try { document.execCommand('copy'); showMessage('API serial copied! (fallback)', 'success'); showCopyStatus(dom.copyApiStatus, 'Copied!'); } catch (errFallback) { console.error('execCommand copy failed:', errFallback); showMessage('Copy failed!', 'error'); } document.body.removeChild(textArea); } });

             setupCollapsibleSections(); // Unchanged call
             rebuildOutput(); // Initial build (will be empty)
             // No initial API call needed until input is applied
        } catch (error) { /* ... (critical error handling unchanged) ... */ showMessage(`Critical Initialization failed: ${error.message}`, 'error', 10000); console.error("Critical Initialization error:", error); document.querySelectorAll('input, select, button, [contenteditable]').forEach(el => { if(el) el.disabled = true; }); if (dom.baseSerial) dom.baseSerial.disabled = true; if (dom.outCode) dom.outCode.contentEditable = false; }
    }
    // --- DOM Ready ---
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp(); // DOM was already ready
    }
</script>
</body>
</html>
